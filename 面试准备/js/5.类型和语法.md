js有7种内置类型: null undefined object number string boolean symbol
变量没有类型,但它们的值有类型


    var a;
    a; // undefined
    b; // ReferenceError:b is not defined
typeOf 对于 undeclared 的变量有安全防范机制(防止报错)
    var a 
    typeOf a; // undefined
    typeOf b; // undefined

如何检查全局变量DEBUG才不会出现ReferenceError错误
    // 这样做会报错
        if(DEBUG){
            console.log("123")
        }
    //  这样是安全的
    if(typeOf DEBUG !== "undefined"){
        console.log("123")
    }

对内建API也有帮助:
    if(typeOf atob == "undefined"){
        atob = function(){...}
    }

一般不用var atob声明变量atob，因为使用var会进行变量提示，就算if语句为false时也会在全局创建atob变量，在有些浏览器中这样重复声明会报错

数组
    和其他强类型不同,js中的数组可以包含任何类型的值
    使用delete运算符后可以将单元从数组中删除,但不会影响数组的length长度
    var a = []
    a[2] = 3
    a.length // 3

    数组不仅可以通过数字进行索引,但它们也是对象,也可以通过字符串键值和属性(但这些不计算在数组长度中)

    var a = []
    a[0] = 2
    a['cc'] = 3
    a.length // 1
    a.cc // 3

    类数组:
        function a(){
            var arr = Array.prototype.slice.call(arguments)
            arr.push(1)
            console.log(arr)
        }
        a("a","b","c")   // ["a","b","c",1]

        Array.prototype.slice.call() 可以将类数组变成数组
        将字符串变成数组 str.split("")
数字
    0.1+0.2===0.3 // false
    在js中采用双精度格式(即64位二进制)
    由于0.1、0.2在转换为二进制时是无限循环的，所以在储存时只能储存为一个近似值
    导致最后得到的结果是0.30000000000000004
    判断0.1+0.2是否等于0.3的方法
    设置一个误差范围值,这个值一般是2^-52 (2.220446049250313e-16),因为在js中精度最多到53个二进制位
    从ES6开始，该值定义在Number.EPSILON中，我们可以直接拿来用，也可以为ES6之前的版本写polyfill：
        if(!Number.EPSILON){
            Number.EPSILON = 2^-52 (2.220446049250313e-16)
        }

    判断两个值是否相等
        function numberEqual(a,b){
            return Math.abs(a-b)<Number.EPSILON
        }
        var a = 0.1+0.2
        var b = 0.3
        numberEqual(a,b)

    js中能被安全呈现的最大整数是2^53-1，有时候js需要处理一些比较大的数字,如64位的id等，所以必须将他们保存为字符串

    整数检测
        Number.isInteger(43)  // true
        Number.isInteger(43.00) // true
        Number.isInteger(43.01) // false

    为ES6之前的版本polyfill Number.isInteger(..)方法：
        if(!Number.isInteger){
            Number.isInteger = function(num){
                return typeOf num == "number" && num%1==0
            }
        }