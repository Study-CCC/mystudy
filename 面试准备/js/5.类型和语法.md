js有7种内置类型: null undefined object number string boolean symbol
变量没有类型,但它们的值有类型


    var a;
    a; // undefined
    b; // ReferenceError:b is not defined
typeOf 对于 undeclared 的变量有安全防范机制(防止报错)
    var a 
    typeOf a; // undefined
    typeOf b; // undefined

如何检查全局变量DEBUG才不会出现ReferenceError错误
    // 这样做会报错
        if(DEBUG){
            console.log("123")
        }
    //  这样是安全的
    if(typeOf DEBUG !== "undefined"){
        console.log("123")
    }

对内建API也有帮助:
    if(typeOf atob == "undefined"){
        atob = function(){...}
    }

一般不用var atob声明变量atob，因为使用var会进行变量提示，就算if语句为false时也会在全局创建atob变量，在有些浏览器中这样重复声明会报错

数组
    和其他强类型不同,js中的数组可以包含任何类型的值
    使用delete运算符后可以将单元从数组中删除,但不会影响数组的length长度
    var a = []
    a[2] = 3
    a.length // 3

    数组不仅可以通过数字进行索引,但它们也是对象,也可以通过字符串键值和属性(但这些不计算在数组长度中)

    var a = []
    a[0] = 2
    a['cc'] = 3
    a.length // 1
    a.cc // 3

    类数组:
        function a(){
            var arr = Array.prototype.slice.call(arguments)
            arr.push(1)
            console.log(arr)
        }
        a("a","b","c")   // ["a","b","c",1]

        Array.prototype.slice.call() 可以将类数组变成数组
        将字符串变成数组 str.split("")
数字
    0.1+0.2===0.3 // false
    在js中采用双精度格式(即64位二进制)
    由于0.1、0.2在转换为二进制时是无限循环的，所以在储存时只能储存为一个近似值
    导致最后得到的结果是0.30000000000000004
    判断0.1+0.2是否等于0.3的方法
    设置一个误差范围值,这个值一般是2^-52 (2.220446049250313e-16),因为在js中精度最多到53个二进制位
    从ES6开始，该值定义在Number.EPSILON中，我们可以直接拿来用，也可以为ES6之前的版本写polyfill：
        if(!Number.EPSILON){
            Number.EPSILON = 2^-52 (2.220446049250313e-16)
        }

    判断两个值是否相等
        function numberEqual(a,b){
            return Math.abs(a-b)<Number.EPSILON
        }
        var a = 0.1+0.2
        var b = 0.3
        numberEqual(a,b)

    js中能被安全呈现的最大整数是2^53-1，有时候js需要处理一些比较大的数字,如64位的id等，所以必须将他们保存为字符串

    整数检测
        Number.isInteger(43)  // true
        Number.isInteger(43.00) // true
        Number.isInteger(43.01) // false

    为ES6之前的版本polyfill Number.isInteger(..)方法：
        if(!Number.isInteger){
            Number.isInteger = function(num){
                return typeOf num == "number" && num%1==0
            }
        }

    特殊的数值
        'NaN' not a number ，意思是不是一个数字
        var a = 2/"a"    //NaN
        typeOf a === "number"   //true
        NaN == NaN //false
        NaN是一个特殊值,它和自身不相等
        可以使用内置的函数isNaN()来检测
        NaN(..)有一个严重的缺陷
            var a = 'foo'
            var b = 2/'foo'
            isNaN(a)  // true
            isNaN(b)  // true

        在ES6后,我们可以使用工具类Number.isNaN(..),ES6之前的polyfill如下:
            if(!Number.isNaN){
                Number.isNaN = function(num){
                    return typeOf num === 'number' &&
                    window.isNaN(num)
                }
            }
        还有个更简单的方法,利用NaN是js中唯一一个不等于自身的值，可以这样写：
               if(!Number.isNaN){
                Number.isNaN = function(num){
                    return num !== num  
                }
            }

    在js中一旦运算结果溢出,会显示Infinity。 无穷除以无穷是NaN，有穷除以无穷是0
    零值
        js中有0值和-0值
        var a = 0/3;  //0
        var b = 0/-3; //-0
        根据规则，对负零转化为字符串会变成"0"
        var a =  0/-3
        a.toString();  // "0"
        a+""; // "0"
        String(a); //"0"
        JSON.stringify(a); //"0"

        要区分-0和0,除了开发调试的窗口,还需要做一些特殊处理:
            function isNegZero(n){
                var n = Number(n);
                return n === -n&& 1/n === - Infinity    
            }
        负零存在的意义: 有些数据使用数字的符号位表示(比如移动的方向),此时如果值为0的变量失去了他的符号，它的方向就丢失了

    ES6中新加了一个方法来判断两个值是否相等,Object.is(..)来判断两个值是否相等,可以处理上诉所有特殊情况
        var a = 0/-3
        var b = 1/'foo'
        Object.is(a,0)  //false
        Object.is(a,-0) //true
        Object.is(b,NaN) //true
    对于ES6之前的,Object有一个简单的polyfill:
        if(!Object.is){
            Object.is = function(a,b){
                if(a===0&&b===0){
                    return 1/a===1/b
                }
                if(a!==a&&b!==b){
                    return true
                }
                else return a===b
            }
        }
    能使用===和==就尽量不要用Object.is(),因为前者的效率更高,更为通用。后者主要使用于特殊情况

值和引用
    js中对基本数据类型是通过值复制来继续赋值/传递的，对复杂数据类型是通过引用复制来赋值/传递的
    由于引用指向的是值本身而非变量,所以一个引用无法更改另一个引用的指向
    var a = [1,2,3]
    var b = a
    b= [4,5,6]
    a;  // [1,2,3]
    函数参数:
        function foo(x){
            x.push(4)
            x;  // [1,2,3,4]
            x = [4,5,6]
            x.push(7)
            x;  // [4,5,6,7]
        }
        var a = [1,2,3]
        foo(a)
        a;   // [1,2,3,4]

    当向函数传递a的时候,实际是将引用a的一个复本赋值给x

    function foo(x){
        x = x+1;
        x;//3
    }
    var a = 2;
    foo(a)
    var b = new Number(2); //Object(a)也一样
    foo(b)
    console.log(b);   // 2
    原因是标量基本类型值是不可改变的,如果一个数字对象的标量基本类型值是2，那么该值