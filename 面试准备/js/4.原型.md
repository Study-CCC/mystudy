js中对象都有一个特殊的内置属性[[ prototype ]]

如果在对象obj中查找a属性,在obj上没有查找到,则会到obj的[[ prototype ]]中查找

所有普通的[[ prototype ]]链最终也会指向Object.prototype

属性设置和属性屏蔽
    给一个对象添加一个属性或者修改一个属性的值
        如果这个对象不包含这个属性，则会去这个对象的[[ prototype ]]中寻找
        如果没找到，则直接对这个对象添加这个属性
        在[[ prototype ]]存在的三种情况
            1. 在[[ prototype ]]中存在，且没有设置为只可读，则会在这个对象上直接添加这个属性，这个属性是屏蔽属性
            2. 在[[ prototype ]]中存在，被设置为可读，则会忽略这个赋值操作，但仍可用Object.defineProperty()对这个属性赋值
            3. 在[[ Prototype ]]链上层存在这个属性并且它是一个setter，则这个属性不会被添加到这个对象,也不会重新定义这个setter

    隐式产生屏蔽
        var obj = {
            a:2
        }
        var obj1 = Object.create(obj)
        obj.a //2
        obj1.a //2
        obj.hasOwnProperty("a")   //true
        obj1.hasOwnProperty("a")  //false
        obj1.a++;   //隐式屏蔽
        obj.a   //2
        obj1.a  //3
        obj1.hasOwnProperty("a")  //true


        obj1.a++相当于obj1.a = obj1.a +1,先通过[[ Prototype ]]查找obj1.a的值,查找到值为2，然后给值加1
        再用[[ put ]]将值3赋给obj1中新建的屏蔽属性a

        construct并不是表示由什么函数构造,.constructor引用只是被委托给了Foo.prototype,
        function Foo() {...}
        Foo.prototype = {...}
        var a = new Foo()
        a.construct === Foo; //false
        a.construct === Object; //true
        但是Object()并没有构造a对象,所以construct表示的并不是由什么函数构造的,a也并没有.construct,
        它只是委托[[ Prototype ]]查找Foo.prototype查找.construct，此时这个对象也并没有,于是到Object.prototype上查找.construct ,
        发现有这个属性，指向内置的Object()函数

        将bar.prototype关联到foo.prototype上
        错误做法:
         1. bar.prototype = foo.prototype 
            这样做会使修改bar.prototype的同时也会修改foo.prototype，这样跟直接使用foo.prototype没有区别
         2. bar.prototype = new Foo()
            这样做虽然可以关联,但是如果Foo函数有副作用,比如给this添加数据属性,修改状态等等,这样会影响到Bar()的后代

        要关联且不产生副作用的方法是使用Object.create(foo.prototype),这样做的缺点是不能直接修改已有的默认对象