1. 内存泄漏和内存溢出
    内存溢出是当一个程序申请内存时，没有足够的内存供其使用，此时会造成内存溢出。
    内存泄漏是当一个程序申请内存后，无法释放对其申请的内存，此时会造成内存泄漏。当内存泄漏次数过多的时候，很容易造成内存溢出
    产生内存泄漏的四种情况:
        1.意外的全局变量
          在函数内声明变量的时候没有使用var导致变量被声明为全局变量，还有使用this定义变量的，函数被全局调用导致this指向全局，因此这个变量
          也被定义为全局变量。
          解决方法： 使用严格模式
        2.闭包
          闭包中引用着上层作用域中的变量，根据垃圾回收机制，当变量被引用时无法对其清理，所以会产生内存泄漏
          解决方法： 在退出函数时将闭包使用的外部变量设为空
        3.遗忘的定时器
          定时器要定时停止时才会被回收，如果没有在退出该定时器所处环境时停止定时器，则会造成内存泄漏
          解决方法： 及时关闭定时器
        4.dom的引用
            当在js代码中保存了dom节点引用时，同样的dom节点有两份引用，一份存于dom中，一份在js中。比如，js代码保存了表格其中一个td元素，
           如果打算删除整个表格时， td元素与其父元素是引用关系，因此该表格依然存在内存中
           解决方法:清除某个元素时，要将dom树中和js中的引用都清除
    如何观测内存泄漏:
        1. 通过chrome的performance也就是以前的timeline观察，根据经验法则，如果连续五次内存回收后，内存占用一次比一次多，则为出现了内存溢出
        2. 使用chrome工具Heap Profiling，这个工具可以记录当前的堆内存快照，并生成对象的描述文件。选择描述文件中的closure如果delta中多个快照中都没有负数，则表示闭包没有销毁
        3. 使用node的process.memoryUsage判断内存泄漏，以heapUsed为准
        
2. js内存清理机制
    js自动有垃圾清理机制，会定时的清理不再用到的内存。
    清理方法有两种：标记清除、引用计数
    标记清理(GC):
        在进入环境时，js会给那些进入环境的变量标记为"进入环境",然后在退出环境时标记为"离开环境"。标记清理会从根节点即全局对象出发给所有可到达的对象进行标记(使用深度遍历)，然后对堆中未进行标记的进行清除
        优点: 1.可以解决引用计数无法清理的循环引用
              2.算法实现简单
              3.垃圾被批量回收，可以提高内存回收的吞吐
        缺点: 1.算法性能跟堆的大小有关，当堆非常大的时候，性能被严重拖低
              2.垃圾回收的延迟较高，会使用户代码停止一段时间
              3.占用内存，每个对象至少需要花费1比特的空间
              4.出现内存不连续的问题
    引用计数:
        语言引擎有一套"引用表",保存着所有变量的引用次数，当引用次数为0时，就表示这个变量不再被用到，因此可以将内存给释放掉
        当两个变量循环引用的时候，引用次数就都为0，永远不会为0，就无法对这两个变量进行清理，如果对这个方法对调用几次就会导致大量的内存无法得到释放，容易造成内存泄漏
        优点: 1.内存可以及时释放，当一个对象引用为0时马上得到释放
              2.延迟低，内存释放的时间均匀地分布在各个时间段
        缺点: 1.无法处理循环引用的对象
              2.每个对象都要附带一个计数字段的空间
3. v8
4. 函数内部不使用var定义一个变量为什么会被定义为全局变量
当出现这个变量时，由于在当前作用域没有声明。则会沿着作用域链找，直到全局作用域还没有发现，则js就会将这个变量声明为全局变量。

5. addEventListener

6. typeOf null为object
    因为在js中不同对象在底层都是为二进制表示,typeOf会将二进制前三位为0的表示为object,而null的二进制都是0,因此
    null检测为object

7. ['1', '2', '3'].map(parseInt)
    输出[1,NaN,NaN],parseInt可以接受两个参数,而map可以传递三个参数,因此map将前两个参数给传递给了parseInt.
    parseInt的两个参数,第一个为要转化的值,第二个为转化进制
    当1传入的时候,传递了1和0,当进制是0的时候按照10进制处理,即返回1
    当2传入的时候,接受2和1,1进制的时候最大值小于2,所以无法解析,即返回NaN
    当3传入的时候,接受3和2,2进制的时候最大值小于3,所以无法解析,即返回NaN