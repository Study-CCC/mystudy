在js中有一些原生函数
作用:为基本数据类型提供该子类特有的方法和属性
常见的原生函数有:
    String()、Number()、Boolean()、Array()、Object()等
    原生函数可以当作构造函数使用,构造出来的对象可能会跟我们设想的有出入：
        var a = new String("abc")
        typeOf a;   //object
        a instanceOf String; //true
        Object.prototype.toString.call(a); //[object String]
    typeOf在这里返回的是对象类型的子类型
    内部属性：
        所以typeOf返回值萎为'Object'的对象都包含一个内部属性[[ class ]],这个属性无法直接访问,一般通过Object.prototype.toString.call(..)来查看
        Object.prototype.toString.call([1,2,3])
        // "[Object Array]"
    封装对象包装:
        var a = "abc"
        var b = new String(a)
        var c  = Object(a)
        typeOf a  // string
        typeOf b  // object
        typeOf c  // object
        b instanceOf String //true
        c instanceOf String //true
        Object.prototype.toString.call(b);   // "[Object String]"
        Object.prototype.toString.call(c)    // "[Object String]"
        一般不推荐使用封装对象(b和c),但它们偶尔也会派上用场
    拆封:
        var a = new Number(12)
        var b = new String('abc')
        var c = new Boolean(true)
        a.valueOf(); //12
        b.valueOf(); //'abc'
        c.valueOf(); //true
        
        在需要用到封装对象中的基本类型值的地方会发生隐式拆封
            var a = new String('abc')
            var b = a + "";  //"abc"
            typeOf a; // Object
            typeOf b; // string