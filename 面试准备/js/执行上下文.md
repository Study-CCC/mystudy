 执行上下文
 当可执行代码（全局代码、函数代码、eval代码）执行时,js引擎会创建一个执行上下文
 js有专门的执行上下文栈来管理执行上下文
 为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组：

```js
ECStack = [];
```
 最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以 ECStack 最底部永远有个 globalContext：

```js
ECStack = [
    globalContext
];
```
思考题
```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();
```

```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()();
```
这两段代码执行结果一样，但执行上下文变化不一样
第一段:
```js
 ECStack.push(<checkscope>,functionContext)
 ECStack.push(<f>,functionContext)
 ECStack.pop()
 ECStack.pop()
```

第二段:
```js
 ECStack.push(<checkscope>,functionContext)
  ECStack.pop()
 ECStack.push(<f>,functionContext)
 ECStack.pop()
```



```js
function foo() {
    function bar() {
         ...
    }
}
```
 函数创建时，各自的[[scope]]为：
 ```js
 foo.[[scope]] = [
   globalContext.VO
 ];

 bar.[[scope]] = [
     fooContext.AO,
     globalContext.VO
 
```