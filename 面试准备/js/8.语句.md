代码块的结果值如同一个隐式的返回,即返回最后一个语句的结果值
例如:
    var a;
     if(true){
         a = 42;
     }
    以上结果会显示42

语法不允许我们将语句的结果值赋值给另外一个变量
    var a,b; 
    a = if(true){
        b = 42;
    }
    这段代码不能运行

递增运算符++和递减运算符--都是一元运算符,他们既可以用在操作数的前面,也可以用在操作数的后面
    var a = 42;
    var b = (a++)
    a;   //43
    b;   //42
  ()本身并不是一个封装表达式,不会在a++产生副作用后执行,a++会先返回42.除非有表达式在a++之后运行,否则还是得不到43
    
    var a = 42;
    var b = (a++,a);
    a;   // 43
    b;   // 43
    在(a++,a)中，a在a++执行之后执行,结果为43，赋值给b
    
    {} + [];  //0
    [] + {};  //"[object object]"
    在第一个表达式中,{}被当作一个空代码块,+[]被显式强制转换为0
    第二个表达式中,+{}被当作一个值,转化为字符串"[object object]"，[]则被转化为""

从ES6开始,{..}也可用于"解构赋值"
    function getData(){
        return {
            a:2,
            b:3
        }
    }
    var {a,b} = getData()
    a;   // 2
    b;   // 3
    相当于下面的代码
        var res = getData()
        var a = res.a
        var b = res.b

运算符优先级:
    用,来连接语句的时候,它的优先级最低,其他操作符的优先级都比它高
    var a = 42
    var b = (a++,a)
    b;  //43

    var a = 42;
    var b = a++,a;
    b;  // 42

    &&运算符的优先级高于=
    &&运算符优先于||
    true || false && false;  // true
    (true || false) && false;  // false

    ?:是右关联的
    true?false:true?true:false    // false
    true?false:(true?true:false)  // false

    =是右关联的
    var a,b,c;
    a = b = c = 42;
    实际上是a = (b = (c = 42))

    var a = 42
    var b = "foo"
    var c = false;
    var d = a && b || c ? c || b ? a : c && b : a;
    d;  //42


    function foo(a){
        a = 42;
        console.log(arguments[0])
    }
    foo(2)   // 42
    foo()    // undefined
    调用foo时,未传入参数的话,arguments的对应单元不会与相应的参数进行建立关联
    因此不建议arguments跟相应的参数同时使用

    在创建一个带有id属性的DOM元素时,也会创建同名的全局变量。例如:
        <div id = 'foo'></div>
        以及:
            if(typeOf foo == 'undefined'){
                foo = 42;       //不会运行 
            }   
            console.log(foo)  // html元素