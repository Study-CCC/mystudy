对象可以通过两种形式进行定义
    1. 通过构造形式
        var obj = new Object()
        这种形式一般添加属性要一个一个添加
    2. 通过声明形式
        var obj = {
            ...
        }
        这种添加属性更加方便

对象是js的基础,js一共有六种简单基础类型(string、number、boolean、null、undefined、symbol(ES6新增))
js内置对象:Number、String、Boolean、Object、Function、Array、RegExp、Date、Error
可以通过这些内置对象创建对应子类型对象
    var str1 = 'abc'
    typeOf str1 //'string'
    str1 instanceOf String  //false

    var strObj = new String('abc')
    typeOf strObj  //'Object'
    strObj instanceOf String //true
js中属性名永远都是字符串，如果使用string以外的其他值都会被转化为字符串

属性描述符(数据描述符)
    Object.defineProperty(obj,prop,desc)
    // obj需要定义的对象,prop当前定义的属性名，desc属性描述符
    // desc有writable(可写)、configurable(可配置)、enumerable(可枚举) 
    添加属性:
        var obj = {}
        Object.defineProperty(obj,"a",{
            value:2,    
            writable:true,
            configurable:true,
            enumerable:true
        })
        obj.a  //2

    configurable改为false是单向操作,不能再由false改为true,不过即使属性是configurable:false还是可以将writable从true改为false，但无法将false改成true
    所有方法创建的都是浅不可变性,只影响目标对象和直接属性,如果目标属性引用了其他对象,则其他对象不受影响
    obj.foo //[1,2,3]
    obj.foo.push(4)
    obj.foo  //[1,2,3,4]

    禁止扩展：禁止一个对象添加新属性,可以使用Object.preventExtensions(obj)
        var obj = {
            a:2
        }
        Object.preventExtensions(obj)
        obj.b = 3
        obj.b  // undefined
    密封: Object.seal(obj) 这个方法实际上会对这个对象调用Object.preventExtensions()并将所有属性标记为configurable:false
          密闭之后不能添加新属性跟重新配置和删除任何配置(虽然可以修改属性的值)
    冻结: Object.freeze(obj) 这个方法是应用对象上最高级别的不可变性,在应用Object.seal()上应用writable:false

访问描述符: getter、setter
        var obj = {
            get a(){
                return this.a
            }
            set a(val){
                this.a  = val
            }
        }
        若是只设置get,不设置set，继续set操作时会忽略赋值操作

存在性: 
        var obj = {
            a:2
        }
        "a" in obj  //true
        "b" in obj //false
        obj.hasOwnProperty("a") // true
        obj.hasOwnProperty("b") // false

枚举:       
        Object.keys() 会返回一个数组,包含所有可枚举类型属性,Object.getOwnPropertyNames()会返回一个数组,包含所有属性,无论是否为枚举型
        in 和 hasOwnProperty() 在于是否查找[[ Prototype ]],in会查找[[ Prototype ]],hasOwnProperty()不会查找




浅复制：对基本数据类型进行值传递，对引用数据类型进行引用传递
深复制：对基本数据类型进行值传递，对引用数据类型进行创建一个新对象复制引用数据类型内容
浅复制方法:
    Object.assign(target,source1,source2)  // 第一个参数是目标对象,后面的参数都是源对象
    第一个参数必须是对象，如果不是对象则会转化为对象，如果只有一个参数则返回该参数
    第一个参数不能是null和undefined，否则会报错，后面源对象参数中数值和布尔值都会被忽略，只有字符串的包装对象会产生枚举型，也不拷贝不可枚举类型
    Object.assign拿出处理数组，会将数组视为对象
    Object.assign([1, 2, 3], [4, 5])
    // [4, 5, 3]
