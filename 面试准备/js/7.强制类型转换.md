将值从一种类型转换为另一种类型通常称为类型转换,这是显示的情况。隐式的情况被称为强制类型转换
显式强制转换让代码更加清晰易读,隐式强制转换让代码更不易读
隐式转换的作用是减少冗余,让代码更简洁
    var a = 42
    var b = a + ""     // 隐式强制类型转换
    var c = String(a)  // 显示强制类型转换


对包含循环引用的对象执行JSON.stringify(..)会出错
var a = {
    a:2,
    b:function(){}
}
JSON.stringify(a)   //"{"a":2}"
var b = [1,function(){},2]
JSON.stringify(b)   //"[1,null,2]"

如果对象中定义了toJSON()方法，JSON字符串化时会首先调用该方法，然后用它的返回值来进行序列化。
var a = {
    a:2,
    b:3
}
a.toJSON = function(){
    return { b:2 }
}
JSON.stringify(a);  // "{"b":2}"

一元运算符+和-一样,会将操作数强制类型转换为数字
 var a = "11"
 var b = +a
 a;  // 11

一元运算符+的另一个常见用途是将日期对象强制类型转换为数字
    var d = new Date("Mon,18 Aug 2014 08:53:06 CDT")
    +d;   //1408369986000

js中构造函数没有参数可以不用带()

~字位运算“非”
    ~x大致等于-(x+1)
    ~可以和indexOf()一起使用，如果indexOf(..)返回-1, ~将其转换为假值0，其他情况一律转换为真值。

显式解析数字字符串
    var a = "42"
    var b = "42px"
    Number(a)   //42
    Number(b)   //NaN
    parseInt(a)  //42
    parseInt(b)  //42

显式强制类型转换最常用的方法是!!
    var a = "0"
    var b = 0
    !! a; // true
    !! b; // false

+号能做数字运算,也能做字符串的拼接
var a = "42"
var b = "0"
var c = 42
var d = 0
a + b;  //"420"
c + d;  //42

var a = [1,2]
var b = [3,4]
a + b;  //"1,23,4" 

对某个操作数继续转化,如果valueOf()不能获得基本数据类型，就会使用toString()获取基本数据类型
在数组中valueOf()获取不到相应的基本数据类型,然后就会使用toString()

-号是数字减法运算符
var a = [3]
var b = [1]
a-b; //2
a和b都会被转换成字符串(通过toString),然后再转化为数字

下面的情况会发生布尔值隐式强制类型转换
    1. if(..)
    2. for(..;..;..) 语句中的条件表达式
    3. while(..)和do..while(..)
    4. ?:中的条件判断表达式
    5. 逻辑运算符(&& ||)

&&和|| 也不一定返回true或者false
    var a=42;
    var b="abc";
    var c=null;
    a || b;  //42
    a && b;  //"abc"
    c || b;  //"abc"
    c && b;  // null

    对于||来说,如果条件判断为true就返回第一个,否则返回第二个
     a||b 大概等于 a?a:b
    对于&&来说,如果条件判断为true就返回第二个,否则返回第一个
     a&&b 大概等于 a?b:a

     function foo(){
         console.log(a)
     }
     var a = 42;
     a&&foo();   //42

     foo()只有在条件判断a通过时才会被调用,如果条件判断未通过,foo()不会被调用( 叫做'短路' )

==和===
    ==允许在相等比较中进行强制类型转换,而===不允许
两者不同类型值比较
    字符串与数字之间的比较
        var a = "42"
        var b = 42
        a === b; //false
        a == b; //true
        js引擎会将字符串类型转化为数字类型进行比较ToNumber()
    其他类型与布尔类型的比较
        var a = "42"
        var b = true
        a == b; //false
        b会被强制转换成数字类型1，a也会被转化为数字类型
    对象和非对象的相等比较
        会将对象转化成基本类型，然后再与非对象进行比较
        var a = "123"
        var b = Object(a)
        a == b; // true
        
        var a = null
        var b = Object(a)
        a == b; //false
        undefined和null一样,因为没有对应的封装对象,所以不能被封装,Object(null)和Object(undefined)均返回一个常规对象
        var a = NaN
        var b = Object(a)
        a == b;  //false
        因为Object(a)相当于new Number(a),由于NaN == NaN 为false，所以a==b为false

    比较少见的情况
        Number.prototype.valueOf=function(){
            return 3
        }
        new Number(2) == 3;//true
        number(2)涉及到类型转换,会使用到valueOf方法
        if(a == 2 && a == 3){
            ...
        }
        Number.prototype.valueOf=function(){
            return i++;
        }


        0==null  //false
        0>=null  //true   
        0<=null  //true
        0==null之所以为false是因为js在将0和null进行比较的时候,不会对null进行转型
        而第二个第三个的时候null会转型为number类型，值为0
        [] == ![]  //true
        2 == [2]   // true
        "" == [null] //true
        第一个在比较的时候右边的会转换为布尔值,左边的也会转变
        第二个数组会继续toNumber进行强制类型转换为数字类型,因为数组的valueOf返回数组本身，所以使用toNumber方法
        第三个[null]会直接转换为""

        a<b涉及的隐式转换
        比较双方先转换为基本类型,如果出现非字符串类型，则toNumber()转换数字类型进行比较
        var a = [42]
        var b = ["43"]
        a < b; // true
        如果比较双方都是字符串，则按字母顺序来进行比较：
        var a = ["42"]
        var b = ["043"]
        a > b; //true


        var a = {b:2}
        var b = {b:3}
        a < b; //false
        因为a是[object Object], b也是[object Object]，所以按照字母顺序a < b并不成立。

        var a = [42]
        var b = "043"
        a < b;  // false ,字符串比较
        Number(a) < Number(b)  //true, 数字比较