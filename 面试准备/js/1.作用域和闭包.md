作用域是一套规则，用于在何处以及如何查询变量。如果查找目的是进行赋值操作，则用LHS查询，如果查找目的是为了查找值，则用RHS查询
词法作用域就是在词法阶段的作用域，词法作用域是由你在写代码时将变量和块作用域写在哪里决定的
跟词法作用域相对的是动态作用域，也就是作用域是与在何处调用有关
词法作用域：
            function a(){
                console.log(c)  //3
            }
            function b(){
                var c = 2;
                a()
            }
            var c = 3
动态作用域:
            function a(){
                console.log(c)  //2
            }
            function b(){
                var c = 2;
                a()
            }
            var c = 3
欺骗词法作用域：
        1. eval()，eval函数可以通过在代码中使用，将eval函数的参数字符串代码内容存于程序中那个位置的代码
        2. with(),with将一对象作为参数，并对这个对象进行with块函数内的代码操作，里面是赋值操作，则在该对象里查找
            该变量进行赋值，如果没有的话，则将这个全局创建这个变量
    eval和with会影响性能，js引擎会在编译阶段对代码进行数项的优化性能，其中有些会通过词法来进行静态分析，判断变量和函数所处的作用域，
    但是出现了eval和with，引擎不能判断里面会接收什么代码，所以引擎会认为eval和with是无效的，也无法为eval和with进行优化
立即执行函数(IIFE): 1. 创建块级作用域，避免了全局作用域中添加变量或者函数
                   2. 定义的任何函数和变量都可以在执行结束时销毁

闭包： 有权访问另一函数内部作用域的函数叫做闭包
    闭包包含以下要点： 1. 函数声明的时候会创建一个独立的作用域
                      2. 子级函数可以访问父级函数的作用域
                      3. 同一作用域的对象可以相互访问
        function f1(){
            var n = 123;
            function f2(){    //f2是一个闭包
                alert(n)
            }    
            return f2;
        }
    闭包的原理: 子函数可以访问父函数的作用域,f1是f2的父函数,f2被赋于一个全局变量,f2的存在依赖于f1，f2始终存在于内存中,因此f1也始终存在于内存中
    闭包应用场景：
        1. 定时器
         原生setTimeout传递的第一个函数不能带参数 
        function f1(a){
           return f2(){
               console.log(a)
           }
        }
        var b = f1(1)
        setTimeout(f1,100)
        2. 封装变量
         用闭包定义能够访问私有函数和私有变量的公有函数
         var bar = (function(){
             var a = 0; 
             function change(val){
                 a = val+a;
             }
              return {
            increment:function(){   //三个闭包共享一个词法环境
                change(1);
            },
            decrement:function(){
                change(-1);
            },
            value:function(){
                return a;
            }
        };
         })()
        3. 循环click点击事件
            var arr = document.querySelectorAll('p')
            for(var i=0;i<5;i++){
                arr[i].onclick=function(){
                    console.log(i)
                }
            }

            解决方案1: ES6 的let块级作用域
            解决方案2: 使用自执行函数,将i作为变量传入   
            解决方案3: 单独设置属性 arr[i].i=i