为什么要用this?
    this提供了一种更优雅的方式来隐式得传递一个对象引用

    使用this
    function identify(){
        return this.name.toUpperCase()
    }
    var me = {name:"cc"}
    identify.call(me)

    不使用this
    function identify(context){
        return context.name.toUpperCase()
    }
    var me = {name:"cc"}
    identify(me)

this实际上是函数在调用时发生的绑定，它指向什么完全取决于函数在哪里被调用
如果使用严格模式，则不能将全局对象用于默认绑定，因为this会绑定到undefined里
硬绑定不可能再修改它的this值
    function foo(){
        console.log(this.a)
    }
    var obj={
        a:2
    }
    var bar =function(){
        foo.call(obj)
    } 
    bar(); //2
    setTimeout(bar,100) //2
    // 硬绑定的bar不可能再修改它的this
    bar.call(window)

在严格模式中,this的默认绑定不是window而是undefined
在node里不存在window，因此this不会指向window,this也找不到window下的全局变量

this的绑定规则
    1. 默认绑定
        独立函数调用，就是不带任何修饰的函数引用进行调用的都默认绑定全局对象
        function foo(){
            console.log(this.a)
        }
        var a = 2;
        foo() // 2
    2. 隐式绑定
        指一个函数被当作引用属性添加到了一个对象上,通过对象名.函数名()进行引用时,如果函数引用有上下文对象,隐式绑定规则会将函数里的this绑定这个对象上
        function foo(){
            console.log(this.a)
        }
        var obj = {
            a:2,
            foo:foo
        }
        obj.foo()  // 2
        链式调用:在链式绑定中,this绑定调用函数的上一层对象
        function foo(){
            console.log(this.a)
        }
        var obj = {
            a:2,
            obj1:obj1
        }
        var obj1 = {
            a:3,
            foo:foo
        }
        obj.obj1.foo()   // 3
        隐式丢失:将一个变量指向一个带有隐式绑定的函数,通过这里变量对这个函数进行调用的时候,函数里面的this不再指向原来隐式绑定的对象
    3. 显式绑定
        通过apply和call、bind函数可以直接指定this的绑定对象
    4. new绑定
        使用new来调用foo时,我们会构造一个新对象,并将它绑定到foo的this上

    优先级： 关于this指向可以根据以下规则按顺序判断：
            1. 是否使用new，如果使用了则this指向这个新创建的对象
            2. 是否使用apply，call等函数进行显式绑定，如果使用了则this指向绑定的对象
            3. 是否被某个上下文对象调用，如果调用了则指向这个上下文对象
            4. 如果都不是的话则是默认绑定，指向全局对象，严格模式下this指向undefined

    箭头函数:
        箭头函数的绑定无法修改，this默认指向父级的this