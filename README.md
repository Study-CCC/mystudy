question： vue ssr
vue(2.0)
 生命周期： 生命周期分为初始化阶段，模版编译阶段，挂载， 销毁
 beforeCreat->created->beforeMount->mounted->beforeUpdate->updated->beforeDestory->destoryed
    初始化阶段:主要进行props，data，methods等vue上一些属性、事件的初始化
 beforeCreat: 发生在创建前,此时vue实例还没有创建，获取不到任何实例上的属性，此生命周期可用来添加loading等加载提示
 created: 发生在创建后，此时可以获取实例上的一些属性，但不能获取dom，这个生命周期可以用来发起异步请求

    模版编译阶段在beforeMount和created之间的被成为模版编译阶段，此阶段只存在与完整版，不存在于运行时版本，此阶段
    会先检测template或者el是否被编译成渲染函数，如果没有则会编译成渲染函数后再进入挂载阶段

    挂载阶段:在这个阶段会将实例挂载到dom上，并开启watcher监听数据变化，当数据变化时会重新渲染视图，并且
    在更新前触发beforeUpdate钩子函数，更新后触发updated函数
 beforeMount: 发生在挂载前，创建vue实例下的虚拟dom，此时不可对dom进行操作
 mounted:发生在挂载后，此时页面上已经有数据了，可以进行dom操作
 beforeUpdate:发生在更新前，可以在这个生命周期函数中进一步更改状态
 updated:发生在更新后，该生命周期函数在服务端渲染时不被调用

    销毁阶段:这个阶段主要取消实例的依赖追踪，并且取消所有的事件监听器
 beforeDestory:发生在销毁前，可以在这清除一些副作用
 destoryed:发生在销毁后，此时实例已经被销毁，该钩子在服务器端渲染期间不被调用。

 porps，methods，data，watch，computed之间的生成前后关系为:
  props->methods->data->watch->computed

 完整版和只包含运行时
    和只运行版本最大的差异是是否存在编译器，编译器是将模版字符串转化为js渲染函数的代码.在完整版中会先检测template或者
    el是否被编译成渲染函数，如果没有则编译成渲染函数以后再进入挂载阶段。而在只运行版本编译都是vue-loader去执行，因此
    只运行版本的体积更小，所以尽可能去使用只运行版本，如果想运行完整版本需要去webpack中配置alias，将vue引用的包转化为
    完整版的包

 双向数据绑定v-modal
    v-modal其实是一个语法糖,默认将input作为props传入，然后当输入框内容改变时触发事件将改变值赋予input从而达到响应式

 父子传值
vue(3.0)
  composition API: 主要是为了解决vue2.0造成的后续维护复杂且代码复用率不高的问题，使用vue2.0的option api时，
                   一个功能的实现可能需要在好几个地方定义属性和方法，这样就比较分散，项目大时一个methods有几十
                   个方法就很不利于维护
  生命周期: 

差异：
      vue3.0： 响应式原理使用proxy，复用逻辑方便 包体积更小 
      vue2.0： 使用defindeProperty， 采用mixin和slot插槽来复用
   

react
  生命周期: 分为挂载,更新,卸载
    挂载阶段是实例初始化并插入dom中
    constructor:在挂载前对实例属性进行初始化
    getDerivedStateFromProps:当传入props改变时会触发这函数，返回一个对象对state进行更新
    render:渲染页面
    componentDidMount
    更新阶段是当state或者props更新时视图发生改变
    getDerivedStateFromProps:当传入props改变时会触发这函数，返回一个对象对state进行更新
    shouldComponentUpdate:当数据改变时判断是否对视图进行更新，这个仅作为性能优化对方式存在，不建议进行深层比较，会非常
                          影响效率
    render
    componentDidUpdate:会在更新后立即处理这个方法
    卸载阶段是将组件从dom移除时调用方法
    componentWillUnmount:在组件卸载及销毁之前调用这个函数，可以在这里清除定时器等副作用

  setState
    setState在合成事件和钩子函数中是异步的，在原生事件和setTimeout中是同步的。
    因为合成事件和钩子函数的执行在更新之前，所以在这里拿不到最新的state导致形成了所谓的异步，可以通过
    setState的第二个参数来获取更新后的结果。在合成事件和钩子函数中多次使用setState会进行批量更新优化
    即一个值多次更新的话只会对最后一次的值进行更新。react的函数实现中会根据变量isBatchingUpdates判断
    直接更新this.state还是放到队列中延迟更新

  事件系统:合成事件系统
    在react底层对合成事件做了两件事：事件委派和自动绑定(不过在es6的class或者使用纯函数时需要手动绑定)
    将所有事件绑定到结构到最外层，使用了一个统一的事件监听器，通过映射来保存所有组件内部的事件监听和处理函数。这样做
    简化了事件的处理和回收机制，效率也有很大提升,解决跨平台兼容性问题。
    在react中也可以使用原生事件，但是在react中使用react原生事件的话要在组件卸载时进行手动移除，否则可能造成内存泄露。
    不要在react中混用合成事件和原生事件，因为原生事件的阻止冒泡会阻止合成事件的触发，但是反过来却不行

  受控组件和非受控组件
    受控组件是通过state来控制表单的值，然后当表单值改变时触发onChange事件来更新state的值，然后重新更新视图，
          受控组件必须要有change事件来改变state，否则表单值不会改变
    非受控组件就是表单的值不受state的影响，不过可以通过defaultValue来改变该表单的值，当需要时可以通过ref获取
    dom来获取组件的值

  react和vue改变值的区别

  virtual dom 
    虚拟dom并没有比优化后的原生操作dom更快，只是采用虚拟dom更方便维护，而且不需要手动去优化dom操作。虚拟dom加上
    diff算法提供了还不错的性能，而且还可以不需要手动优化，因此框架采用了虚拟dom的方式。
  
  pureComponent
    这个组件一般是用来性能优化的，这个组件会当属性和状态改变时，跟之前的属性和状态进行浅比较，当浅比较返回false则
    组件会重新渲染。深比较代价比较昂贵，所以选择了浅比较这种方法。
  
  immutable
    js对象如果引用了另外一个对象，对该新对象进行属性赋值的话会影响原来的对象，这样可能会造成非常大的隐患。
    因此需要使用深拷贝，但是这样效率又是比较低。因此出现了immutable来避免深拷贝造成的内存的浪费，immutable
    就是使用了结构共享，新对象中和旧对象相同的部分会采用共享的方式以方便节约内存，一个属性改变只会影响该节点和
    受它影响的父节点。
    优点: 节约内存，可以使用这个来对react中数据是否变化进行判断(immutable.is)来达到深比较的效果
    缺点: 容易和原生对象混淆，immutable对象的有些api跟原生对象不一样，容易混淆使用，在某些需要转化为js对象的时候
          容易忘记转化(immutable.formJS)
  refs使用
    React.createRef()
    useRef()
  React.forwardRef
    可以通过这个获得子组件相关的dom引用，比如子组件包裹了一个input，可以通过这个来获取input的dom引用

http
  TCP/IP
    通常使用的网络是这个协议的基础上运作的，http是这个协议上的一个子集。互联网中相互通信就必须基于相同的方法
    如何通信，使用什么设备，这些都是需要一种规则，而这种规则就被称为协议
    TCP/IP协议中最重要的一点就是分层，分为应用层、网络层、传输层、数据链路层，分层是有好处的，比如某个地方需要
    修改的话则需要将整个协议替换掉，而分层的话就只需要修改所在层就行，把每个层接口修改好之后就可以自由修改每个
    层了
    应用层
      决定了向用户提供服务时的通信活动，比如电子邮箱发送，文件传输访问等，http就在该层
    传输层
      传输层对上层应用层，提供两台计算机之间的数据传输，在传输层有两种性质不同的协议TCP和UDP
    网络层
      网络层就是处理网络上的数据包，该层规定以什么样的路径将数据包传送到对方计算机上
    链路层
      用来连接网络的硬件部分，光纤、网卡等都属于链路层
    在通过TCP/IP进行网络通信时发送端会从应用层往下走，接收端会从链路层往上走
    比如：一个用户发送一个web页面的请求时，会从应用层发送该http请求，然后传输层为了传输方便会对该请求
        进行分割，每段报文加上序号并加上端口号，网络层接收到请求报文后增加通信目的地的mac地址，通过链路
        层发送给服务器，服务器在接收到后从链路层往上发，到达了应用层便算是接收到了请求。发送端在发送数据
        时，每一次必会加上该层所属的首部信息，接收方在接收后每一层会去掉该层的首部信息
    IP是一种协议，IP地址是节点被分配到的地址，MAC地址是网卡所属的固定地址，IP地址是可换的，MAC地址是固定的
  三次握手、四次挥手
    三次握手是发送方发送一个带标记的请求报文给接收方，接收方接收到后返回一个带标记的信号给接收方表示接收到了你的请求，
    发送方接收到这个信号后再发送带标记的信号给接收方表示接收到了接收方返回的信号，然后建立连接
  DNS
    DNS是跟http一样处于应用层的协议,dns负责域名到IP地址之间的解析。用户通常通过采用主机名和域名去访问计算机，
    因为字母配数字比起纯数字更符合人们的记忆习惯，而计算机对于这种地址理解起来却比较困难，因此出现了dns去进行解析，
    dns提供通过域名查找ip地址，或者通过ip地址反查找域名的服务。
    流程:
      用户主机中运行着dns的客户端
      浏览器会将url中抽出域名部分，并将这部分传递给客户端
      dns客户端会向dns服务端发送一个查阅报文，该报文中包含着要访问主机字段
      dns客户端最后会收到服务端返回的目标地址ip地址，然后传递给浏览器
      浏览器收到后会建立与该ip地址的联系，发起tcp连接
  http协议
    http协议是用于客户端和服务端之间的通信，请求文本或资源的被称为客户端，提供资源的被称为服务端
    http协议是无状态协议，不对发送过和请求过的通信状态进行保存，这是为了更快地处理更多事务，确保协议的可伸缩性
  GET POST区别
    get一般用于获取页面资源，而post用于提交一个form表单，用来获取一个有结果的页面
    比如get用来获取一个html或者是一个图片，由于这些资源都是幂等的所以可以对get请求设置缓存
    post请求一般都是不幂等的，比如提交一个商品下单页面，这个是需要向服务器发起请求的，是不能设置缓存的
  http1.1
    持久连接
      为了解决http1.0每次通信都需要建立一次连接造成大量通信量的开销，http1.1提出了持久连接，就是只有当
      一方提出需要断开连接的时候才会断开连接
  cookie
    cookie的引入是为了解决http无状态，若是给http设置有状态则需要大量的内存会给服务器造成很大负担，若是
    无状态则无法对之前的状态进行保存，cookie的出现便很好的解决了这个问题，cookie技术通过在请求和响应报文
    中写入cookie来对客户端的状态进行保存
  报文结构
    报文首部 + 空行 + 报文实体
    请求报文: 请求行 + 请求头 + 实体
    响应报文： 状态行 + 消息报头 + 响应正文
    请求行：请求方法 请求路径 HTTP版本
    状态行：状态码 原因短语 HTTP版本
  分块传输编码
    一个资源量大的页面在请求资源未传输完成之前浏览器是无法显示的，可以通过将这个资源进行分块传输
    来让浏览器页面逐步显示
  发送多数据对象集合
    http采用了MIME(多用途因特网邮件扩展)机制允许邮件处理文本、图片、视频等多类型的数据
  范围请求
    下载某个很大的文件时，如果突然断网了，由于http是无状态的则需要重新下载。因此http采用了范围
    请求的方法，就是将一份资源分为多个范围进行请求
  队头阻塞
    由于http是基于请求应答的模式来进行的，报文必须是一发一收的，如果队首的请求处理太慢，会阻塞后面的请求
    解决方式: 1. http1.1 采用了并发连接的方式，对于一个域名允许分配多个长连接，相当于增加了任务队列
            2. 域名分片，HTTP 协议和浏览器不是限制并发连接数量，可以多开几个域名，将域名都指向一个服务器
  http状态码
    1xx: 信息性状态码  请求正在处理中
      101: 切换协议，就比如http切换成https时，之前的请求都会返回101
    2xx: 成功性状态码  请求处理成功
      200:请求被成功处理了，内容也被正常返回
      204(no content):请求被正常处理,但是响应报文中不包含实体主体部分
      206:表示进行范围请求,Content-Range表示请求的范围
    3xx: 重定向状态码  请求需要附加操作进行处理 (如果不做重定向可能会导致流量白白流失)
      301:永久重定向,表示资源已被分配新的uri(空间服务器不稳定,域名到期不想续费)
      302:临时重定向,表示资源不是永久移动，还有可能发生改变
      304:表示服务端资源未改变，可以直接使用缓存的资源
    4xx: 客户端错误状态码  服务器无法处理请求
      400:表示请求中存在语法错误，需修改请求内容后再次发生请求
      401:用户认证失败
      403(forbidden):请求资源访问被服务器拒绝了
      404(not found):服务器上无法找到请求的资源
    5xx: 服务端错误状态码  服务器处理请求出错
      500:服务端在执行过程中发生了错误
      503:服务器超负荷或者停机维护,无法处理请求
  代理
    代理是一种拥有转发功能的应用程序，扮演着客户端和服务器的中间人，将客户端发送的请求转发给服务器，并将
    服务器的响应转发给客户端。
    代理有缓存代理、透明代理(不对报文做任何加工的代理)、非透明代理
    正向代理
      正向代理是代理客户端，由代理服务器访问目标服务器。这个可以用于解决不能访问目标服务器的问题，比如访问谷歌，也可以加速访问资源，正向代理可以隐藏客户端的信息,vpn也是利用了正向代理的原理
    反向代理
      反向代理是代理服务端，由代理服务器来接受internet上的请求，然后将请求转发给内部网络的服务器。并将得到的结果返回给客户端，反向代理中客户端并不知道自己访问的是一个代理。一般设置反向代理后需要修改DNS让域名解析到代理服务器IP
      使用这个可以确保内网的安全，阻止web攻击。  负载均衡，通过反向代理服务器来优化服务器的负载
  no-cache: 不缓存过期的数据
  no-store: 不进行缓存
  If-Match: 只有这个值跟Etag值匹配上时,服务器才会接受请求
  If-None-Match: 只有这个值没有跟Etag匹配上，服务器才会接受请求
  If-Modified-Since: 只有在设置的时间后资源发生了更新，服务器才会处理请求，如果没有发生更新则返回304
  Last-Modify: 资源最后修改的时间
  User-Agent: 用于传递浏览器的种类
  Etag: 资源唯一标示符，由服务器分配，分为强Etag和弱Etag，强Etag是无论资源发生了多么微妙的变化都会变化，弱Etag是资源发生了根本性的变化才会变化
  Location: 配合URI进行重定向
  Allow: 能支持的HTTP方法
  http1.1 默认连接为持久连接，若想在http1.0持久连接则需要设置connection：keep-alive
  http缺点: 不安全，明文不加密容易被窃听，无法验证内容的完整性，内容可能被修改。
  网关
    网关是转发其他服务器通信数据的服务器
  隧道
  缓存

  跨域： 指的是由于浏览器的同源政策，浏览器不允许一个域脚本加载访问另外一个域，同源就是两个页面具有相同的协议、端口号、域名。这三者任意有一个不同都不属于同源。跨域请求是可以正常发出，但是返回结果会被浏览器拦截。
    解决方案: 前端方面：jsonp：jsonp是利用了script、img、link等标签可以加载跨域资源的原理。缺点是只支持get请求，不支持post
                     document.domain：只要设置相同的domain，两个页面就可以实现跨域通信
             后端方面：cors

https
  与ssl(安全套接层)和TLS(安全传输层协议)结合的http被称为https  
  https与http相比会更慢，除了和tcp连接发送http请求相应之外，还要进行ssl通信。第二点就是ssl还在客户端服务端都需要进行加密和解密处理，通过这种没有根本性的解决办法，只能使用ssl加速器这种硬件来改善该问题。
为什么不一直使用https： 1. https机密资源需要消耗更多的cup和通信资源，如果每次都消耗那么多资源，能够处理的请求会随之减少。所以只会在一些比较敏感的资源上会进行https通信
                     2. https证书需要花钱，这点对于个人网站之类的就比较不划算。
 SSL
  通常HTTP和TCP直接通信，当使用了SSL时，HTTP先跟SSL通信，SSL再跟TCP通信
  ssl采用一种公开密匙加密的加密处理方式
 共享密钥加密(对称密钥加密)：使用同一把密钥加密解密的方式，需要将密钥发送给对方，加密后的数据发送给对方，但是通信被窃听的话就失去加密的意义了。
 公开密钥加密: 使用一把公开密钥和一把私有密钥进行加密，公开密钥大家都可以获得，对方采用公开密钥进行加密，然后自己采用私有密 钥进行解密，这样就不用担心密钥被别人窃取。
 https采用混合加密机制
  共享密匙加密相对不安全，公开密钥加密相对处理太慢。因此https采用了混合加密，采用两者结合。使用公开密钥加密的方式将密钥发送给对方，然后再采用共享密钥的方式来进行数据传送 
ca证书
  公开密钥加密方式还是存在一些问题的，比如无法确定公开密钥本身就是货真价实的公开密钥，在发送密钥的途中，可能会被攻击者攻击替换公开密钥，这样便无法验证这密钥是否是真正的密钥。为了解决这些问题可以使用数字证书认证机构和其机构颁发的公开密钥认证证书。
  数字认证机构的业务流程： 首先服务器的运维人员会想该机构提出公开密钥的申请，数字机构在判明申请者的身份之后会对已申请的公开密钥进行签名，然后分配这个已经签名的公开密钥，并将公开密钥放入公开证书并绑定在一起
XSS(跨站脚本攻击)
  指存在安全漏洞的网站注册用户浏览器内运行非法的html或者js进行的攻击，动态创建的html可能隐藏着安全隐患。
  xss分为三种基于dom、反射型、储存型
  基于dom是通过脚本来对页面对dom对象进行操作从而达到攻击效果
  反射型是在恶意网站通过注入了能获取用户隐私信息的脚本来获取用户的隐私，比如在一个网站上的form提交，通过恶意脚本在用户提交时获取用户的信息。
  储存型是服务器会将用户的数据储存在服务端，攻击者通过将一些恶意脚本写入输入的数据中，然后其他人访问这些数据时这些恶意脚本就会执行，达到获取用户信息的效果
  1. 通常xss都是利用虚假的表单骗取用户的个人信息
  2. 利用脚本获取用户的cookie值，攻击者借用用户的身份发起恶意请求
  解决: 1. 检查输入： 对用户输入的一些特殊字符进行检测，比如script标签进行编码或者过滤
        2. httpOnly: 设置这个让用户无法通过脚本获取cookie
CSRF(跨站请求伪造)
  通常是借用用户的cookie来发起恶意请求。
  流程： 用户登录网站A后，会产生cookie信息并返回给浏览器。然后用户未退出网站A，打开另外一个tab页进入恶意网站B。网站B便会利用用户的cookie信息发送一些请求给网站A，就比如：用户A在银行b有一个账户，登录进这个银行b的网站后，攻击者恰好也有这个银行的账户，诱导用户进他的网站c后，借用用户A在银行b的cookie信息在网站c发送一些汇款请求给攻击者的账户，这样就达到了攻击的效果。(之所以可以从c获取a的cookie是因为html的src可以进行跨域请求，类似于jsonp原理)
  防御:
    1. 通过设置token的形式，攻击者不能获取用户http请求中的token，在服务端设置一个拦截器，如果token不正确便被当成csrf攻击
    2. 验证http referer字段，这个字段记录了用户请求的来源地址，如果来源地址不是那个网站地址，则被当成csrf攻击，当然这样并不一定安全，在一些老旧浏览器中黑客还是可以修改这个字段的。
    3. 验证码，对一些存在安全隐患的操作通过验证码来通知用户是否同意
  chrome的sameSite：用于限制第三方cookie，从而减少csrf的风险
      可以设置了strict，lax，none三个属性
      strict： 最为严格，只有当前url的时候才会带上cookie，这个虽然比较安全，但是体验不好，比如从爱奇艺网站点击进一个视频准备观看，还是需要重新登录获取登录状态
      lax：限制了部分，导航到目标网址只有三种情况会发送，a标签，link标签，get表单
      none：显式关闭sameSite属性
  http/2
    头部压缩
    多路复用
    
SQL注入
  SQL注入就是将SQL语句改写成开发者意想不到的形式进行攻击，比较常见的例子就是对SQL语句进行字符串拼接，直接使用用户输入的文字作为变量，这样用户只要在中间进行修改，添加一下delete之类的关键字，便可以达到SQL注入的效果。解决方法就是过滤用户输入的特殊字符，禁止使用字符串拼接sql语句
js
  dom事件流:事件捕获最先发生，然后实际的目标元素接受到事件，最后一个阶段是冒泡
    捕获:从最外层dom结构沿dom树依次向下触发，直至到达触发事件节点
    冒泡:从触发事件节点沿dom树依次向上触发，直至到达document对象 
      使用场景:一个购物车列表中，点击列表item的文字会冒泡到最外层触发item的点击事件跳转到item的详情页面。
             阻止冒泡就是点击旁边的删除按钮不想跳转到item的详情页面
    可以通过addEventListener添加事件处理函数，addEventListener可以传入三个参数：事件名，事件处理函数，布尔值(true表示在捕获阶段调用事件处理函数false表示在冒泡阶段处理程序)
    js中可以通过stopPropagation停止事件继续传递，vue中可以使用stop修饰符@click.stop
  ajax
    ajax是利用js和dom的操作，达到web页面局部刷新的异步通信手段 
  事件循环机制
    这个是js用来处理事件执行顺序的一种机制，js遇到同步任务会加入主线程执行，遇到异步任务时会将该异步任务加入队列中，
    待主线程中任务执行完毕后再从异步任务队列中出列异步任务到主线程执行，在执行过程中如果遇到了异步任务则会继续加入
    到异步任务队列，在执行完主线程任务完后再继续获取异步任务队列任务，如此循环直至主线程和异步队列任务都执行完为止。
    这里的异步任务队列也是分为微任务队列和宏任务队列，微任务有promise.then 宏任务有setTimeout,setInterval,setImmediate,在执行完主线程后会先执行微任务在执行过程中遇到异步任务会加入相应的队列任务中，在微任务队列
    清空后会开始执行宏任务，在执行过程中遇到异步任务会加入相应的队列任务，执行完这个异步任务会检测是否存在微任务，
    如果存在则执行微任务队列，则继续执行微任务队列任务，如果没有则继续执行宏任务队列任务直至宏任务微任务队列都清空
    宏任务: setTimeout setInterval requestAnimationFrame setImmediate
    微任务: promise.then
  为什么要区分宏任务和微任务
    为了可以插队,如果不区分宏任务和微任务就无法在下一次事件循环之前进行插队，处理异步事件的优先级

  原型和原型链
    每个对象创建时都会有一个与之相关联的对象，这个对象称之为原型，当查找一个对象的方法或者属性时，如果在这个对象上
    不存在就会在对象的__proto__上查找，这个__proto__指向的就是对象的原型，当在对象的原型上找不到时会沿着对象原
    型的原型去查找，一直到null为止，这个查找的过程就叫原型链。原型链是ES的主要继承方式，同一个构造函数创建的实例
    都共享着同一个原型，通过原型可以达到给每个实例添加一个统一的方法

  作用域
    作用域是一套用来规定如何储存和查找变量的规则

  闭包
    闭包指的是引用了另一个函数作用域的函数，闭包的原理是利用了作用域链的特性，在当前作用域找不到该变量时会去沿着
    作用域链查找。闭包可以使用外部函数变量，可以利用闭包做到隐藏变量，防止影响全局变量的效果，每个函数在创建的时候
    都会有个scope属性用来保存上一级的作用域
    闭包会保留它们包含函数的作用域，因此比其他函数更占内存，过度使用闭包容易造成内存泄露

  instanceof
    通过判断对象实例的原型链上是否存在与构造函数的prototype相等的原型

  new
    1 创建一个新对象
    2 将对象的原型指向构造函数的原型
    3 执行构造函数的代码并将this指向新对象
    4 返回这个对象
  
  es5和es6继承
    es5采用函数继承的方式，以prototype来实现继承，es6采用class继承的方式，使用extend来实现继承
    es6的继承方式实际是es5的语法糖，不过语法上可以支持正式的面向对象编程，但是实际背后也是原型和
    构造函数的概念
  面向对象编程
    就是将一个问题把它抽象成对象的概念，就是说这个这个问题有哪些对象，给这些对象赋予一些属性和方法，然后
    让这些对象去执行自身有的方法去解决这个问题
  ES6
  观察者模式和发布订阅模式
    观察者模式中就是观察者和目标直接进行交互
    发布订阅模式是订阅者和发布者互不干扰，通过调度中心进行交互，发布订阅模式和观察者模式实现原理虽然雷同，
    但是使用这种方式可以抽离出调度中心单独成一个文件，可以对一系列的订阅事件进行管理，这样相比观察者模式
    中的事件更加方便维护
css
  BFC
    bfc直译为块级格式化上下文，是页面独立的一块渲染区域，有着独特的渲染规则。其中的元素布局不受外界的影响，并且
    在一个bfc这种，块盒和行盒都会垂直沿着父元素的边框排列
    在bfc中内部的box会在垂直方向一个接着一个地放置，垂直方向的距离由margin决定
    bfc是一块独立的区域，不受外部影响
    计算bfc高度时，浮动元素也参与计算
    开启bfc：
      display不为none
      position不是static或者relative
      overflow不是visible
    作用：
      1. 避免边距重叠
      2. 自适应两栏布局
      3. 清除浮动
  居中
    水平居中:
      块级:margin: 0 auto;
      行内:text-align:center;
      块级和行内:display:flex; justify-content:center;
               使用position
    垂直居中:
      块级:.parent{position:relative;}child:{position:absolute;top:50%;transform:translateY(-50%)}
      行内:设置line-height高度与height一致  
    水平垂直:
      利用flex布局:justify-content:center;align-items:center;
  flex

  清除浮动
    额外标签
    bfc
    伪元素
  边距重叠
    两个块级盒子的垂直边距会重合，它们的边界宽度是边界临界值的最大值
    解决的办法是创建bfc，使用padding代替
浏览器
  回流重绘
    回流是指dom元素的尺寸或者布局等属性发生的改变引起了元素的重新构建被成为回流，应该尽量避免回流，回流会影响页面性能
    重绘是指元素的外观、风格等发生改变，不影响布局的被称为重绘
    回流必定会引起重绘，重绘不会引起回流。
    引起回流的操作：增添或删除dom、元素位置改变、内容改变
    引起重绘的操纵：改变字体颜色、背景颜色
  如何减少回流重绘
    浏览器的帮忙:浏览器会维护一个队列，把所有可能引起的回流和重绘放入这个队列，等到队列中的操作达到了一定的数量或者到了
    一定的时间间隔，浏览器就会进行一个批处理
    通过className去一次性修改样式
    避免频繁访问直接计算后的样式，将计算值缓存下来
    对于需要多次添加的子元素，先将这些子元素使用虚拟dom的形式克隆下来，然后再添加上去
  一个页面从输入url到页面加载完成，这个过程中都发生了什么
cookie localStorage sessionStorage的区别
作用不同，cookie用于储存客户端和服务端之间的信息传递，localStorage用于储存本地数据

0.1 + 0.2 != 0.3
  由于js采用的是ieee 754进行数字存储，采用这种存储方式在计算中会发生两处精度缺失。
  第一处是在将小数转化了二进制时，由于有效数字只能存储52位，而0.1和0.2保存下来时无限循环
  小数，所以会对超出部分进行取舍处理，这样就导致了第一处的丢失。第二个部分就是对阶计算，要将
  小的指数转化了大的指数，必然会把52位有效域最右边的给挤出去，挤出去的部分也会发生舍入，这样
  就发生了进一步的丢失。这样就导致了0.1 + 0.2 != 0.3
解决方式：
  1. 将小数化成整数，但是对大数支持依然不好
  2. 采用第三方库, Math.js big.js
ieee 754存储方式
  第一位储存符号位
  2-11位储存指数域  【-127，128】
  3-64位储存有效数字位

移动端
  适配移动端


react 17 vs vue3

写法上是相似的，不过在底层实现是没有关系
hooks函数每次更新都会执行
vue是通过响应式和生命周期函数来进行更新

vue3 template exploer

react自由度更高，比较考验开发者的编程能力
vue：根据组件划分，组件之间通过响应式通知，组件内部通过vdom计算diff
vdom 用js的object来描述dom节点，跨端
react没有响应式，完全是通过diff

react fiber所谓的时间切片
1. 任务可以切开 利用空闲时间计算
2. diff可以中断

vue中做了静态标记，静态的不会采用diff

vue性能优化手段


js开启多摄

小程序运行机制

rn运行原理