question： vue ssr
vue(2.0)
 生命周期： 生命周期分为初始化阶段，模版编译阶段，挂载， 销毁
 beforeCreat->created->beforeMount->mounted->beforeUpdate->updated->beforeDestory->destoryed
    初始化阶段:主要进行props，data，methods等vue上一些属性、事件的初始化
 beforeCreat: 发生在创建前,此时vue实例还没有创建，获取不到任何实例上的属性，此生命周期可用来添加loading等加载提示
 created: 发生在创建后，此时可以获取实例上的一些属性，但不能获取dom，这个生命周期可以用来发起异步请求

    模版编译阶段在beforeMount和created之间的被成为模版编译阶段，此阶段只存在与完整版，不存在于运行时版本，此阶段
    会先检测template或者el是否被编译成渲染函数，如果没有则会编译成渲染函数后再进入挂载阶段

    挂载阶段:在这个阶段会将实例挂载到dom上，并开启watcher监听数据变化，当数据变化时会重新渲染视图，并且
    在更新前触发beforeUpdate钩子函数，更新后触发updated函数
 beforeMount: 发生在挂载前，创建vue实例下的虚拟dom，此时不可对dom进行操作
 mounted:发生在挂载后，此时页面上已经有数据了，可以进行dom操作
 beforeUpdate:发生在更新前，可以在这个生命周期函数中进一步更改状态
 updated:发生在更新后，该生命周期函数在服务端渲染时不被调用

    销毁阶段:这个阶段主要取消实例的依赖追踪，并且取消所有的事件监听器
 beforeDestory:发生在销毁前，可以在这清除一些副作用
 destoryed:发生在销毁后，此时实例已经被销毁，该钩子在服务器端渲染期间不被调用。

 porps，methods，data，watch，computed之间的生成前后关系为:
  props->methods->data->watch->computed

 完整版和只包含运行时
    和只运行版本最大的差异是是否存在编译器，编译器是将模版字符串转化为js渲染函数的代码.在完整版中会先检测template或者
    el是否被编译成渲染函数，如果没有则编译成渲染函数以后再进入挂载阶段。而在只运行版本编译都是vue-loader去执行，因此
    只运行版本的体积更小，所以尽可能去使用只运行版本，如果想运行完整版本需要去webpack中配置alias，将vue引用的包转化为
    完整版的包
 compute和watch的区别：
    watch是对数据进行监听，当数据改变时会执行回调，更多的使用于数据变化需要执行异步或者是一些计算量比较大的情况，
    compute是计算属性，具有缓存，可以用于避免每次获取值的时候都需要重新计算。
 proxy和object.defineProperty
  proxy不仅可以代理对象，还可以代理数组，并且可以不用像object.defineProperty那样代理整个对象还需要通过递归便利的
  方式，提高了效率。
 双向数据绑定v-modal
    v-modal其实是一个语法糖,默认将input作为props传入，然后当输入框内容改变时触发事件将改变值赋予input从而达到响应式

 父子传值
vue(3.0)
  composition API: 主要是为了解决vue2.0造成的后续维护复杂且代码复用率不高的问题，使用vue2.0的option api时，
                   一个功能的实现可能需要在好几个地方定义属性和方法，这样就比较分散，项目大时一个methods有几十
                   个方法就很不利于维护
  生命周期: 

差异：
      vue3.0： 响应式原理使用proxy，复用逻辑方便 包体积更小 
      vue2.0： 使用defindeProperty， 采用mixin和slot插槽来复用
   

react
  生命周期: 分为挂载,更新,卸载
    挂载阶段是主要进行组件状态的初始化
    constructor:在挂载前对实例属性进行初始化
    componentWillMount
    componentDidMount
    更新阶段是当state或者props更新时视图发生改变
    getDerivedStateFromProps:当传入props改变时会触发这函数，返回一个对象对state进行更新
    shouldComponentUpdate:当数据改变时判断是否对视图进行更新，这个仅作为性能优化对方式存在，不建议进行深层比较，会非常
                          影响效率
    render
    componentDidUpdate:会在更新后立即处理这个方法
    卸载阶段是将组件从dom移除时调用方法
    componentWillUnmount:在组件卸载及销毁之前调用这个函数，可以在这里清除定时器等副作用
  useCallback、useMemo
    一个用于对函数进行缓存，一个对计算量进行缓存。这两个都是对性能进行优化，避免不必要对计算。
  setState
    在 React 管理的事件回调和生命周期中，setState 是异步的，而其他时候 setState 都是同步的。这个
    问题根本原因就是 React 在自己管理的事件回调和生命周期中，对于 setState 是批量更新的，而在其他时候
    是立即更新的。因为合成事件和钩子函数的执行在更新之前，所以在这里拿不到最新的state导致形成了所谓的异步，
    可以通过setState的第二个参数来获取更新后的结果。在合成事件和钩子函数中多次使用setState会进行批量更新优化
    即一个值多次更新的话只会对最后一次的值进行更新。react的函数实现中会根据变量isBatchingUpdates判断
    直接更新this.state还是放到队列中延迟更新
  函数组件中setState
    函数组件的state是通过闭包的形式引用state，而不是通过this.state引用的，所以函数组件中的state一定是旧值
  hooks和类组件区别
    hooks更加轻量，需要什么钩子就引入什么钩子进来，不像class组件所有生命周期都会被继承，hooks也更符合react的
    函数式编程的理念
    hooks更加利于逻辑复用。
    hooks让复杂组件变得更容易理解，在类组件中一些获取数据和事件监听之类的逻辑都写在componentDidMount中，
    这样很多代码写在一些很不利于维护，而且事件监听也需要在componentWillUnMount中清除，这样相关联的事件
    分开写也是很容易出现bug的。使用hooks便可以写在一起。
    缺点： hooks里面有着严格的规则约束，不能在判断语句里面写hooks，因为hooks是通过调用顺序来正确更新相应的
    状态，以及调用相应的钩子函数，一旦在循环或条件分支中使用就会引起调用顺序的不一致性，从而导致出现bug
          有些class生命周期在hooks中并没有，比如componentDidCatch(捕获在render中的catch)
  jsx
    jsx是js的一种语法扩展，是一种模版语言，可以在js中可以写html语句。浏览器是不支持jsx的，所以需要使用babel去
    对jsx进行转化，jsx会被编译成react.createElement
  事件系统:合成事件系统
    在react底层对合成事件做了两件事：事件委派和自动绑定(不过在es6的class或者使用纯函数时需要手动绑定)
    将所有事件绑定到结构到最外层，使用了一个统一的事件监听器，通过映射来保存所有组件内部的事件监听和处理函数。这样做
    简化了事件的处理和回收机制，效率也有很大提升,解决跨平台兼容性问题。
    在react中也可以使用原生事件，但是在react中使用react原生事件的话要在组件卸载时进行手动移除，否则可能造成内存泄露。
    不要在react中混用合成事件和原生事件，因为原生事件的阻止冒泡会阻止合成事件的触发，但是反过来却不行
    自动绑定: 自动将组件内方法this绑定到当前组件
  受控组件和非受控组件
    受控组件是通过state来控制表单的值，然后当表单值改变时触发onChange事件来更新state的值，然后重新更新视图，
          受控组件必须要有change事件来改变state，否则表单值不会改变
    非受控组件就是表单的值不受state的影响，不过可以通过defaultValue来改变该表单的值，当需要时可以通过ref获取
    dom来获取组件的值

  virtual dom 
    虚拟dom并没有比优化后的原生操作dom更快，只是采用虚拟dom更方便维护，而且不需要手动去优化dom操作。虚拟dom加上
    diff算法提供了还不错的性能，而且还可以不需要手动优化，因此框架采用了虚拟dom的方式。
  
  diff算法
    diff算法是通过对新旧dom树进行比较来判断需要进行的最小dom操作，diff通过深度优先遍历来对两颗dom树进行比较。
    首先是判断旧节点是否存在，没有旧节点则就说明页面是初始化的时候，此时不需要进行比较，直接全部新建。如果存在的
    话，会对相应dom节点进行比较，先比较dom的tag类型，然后再比较文本类型，属性，如果都相同的话再对子元素进行
    比较。如果发生了变化就进行相应的替换。如果有新增的dom节点的话，会在同级查找是否有与这个节点key相同的dom，
    存在的话就就地复用，如果没有就新创建，如果dom删除了就直接进行删除。

  pureComponent
    这个组件一般是用来性能优化的，这个组件会当属性和状态改变时，跟之前的属性和状态进行浅比较，当浅比较返回false则
    组件会重新渲染。深比较代价比较昂贵，所以选择了浅比较这种方法。
  
  immutable
    js对象如果引用了另外一个对象，对该新对象进行属性赋值的话会影响原来的对象，这样可能会造成非常大的隐患。
    因此需要使用深拷贝，但是这样效率又是比较低。因此出现了immutable来避免深拷贝造成的内存的浪费，immutable
    就是使用了结构共享，新对象中和旧对象相同的部分会采用共享的方式以方便节约内存，一个属性改变只会影响该节点和
    受它影响的父节点。
    优点: 节约内存，可以使用这个来对react中数据是否变化进行判断(immutable.is)来达到深比较的效果
    缺点: 容易和原生对象混淆，immutable对象的有些api跟原生对象不一样，容易混淆使用，在某些需要转化为js对象的时候
          容易忘记转化(immutable.formJS)
  refs使用
    React.createRef()
    useRef()
  React.forwardRef
    可以通过这个获得子组件相关的dom引用，比如子组件包裹了一个input，可以通过这个来获取input的dom引用

http
  TCP/IP
    通常使用的网络是这个协议的基础上运作的，http是这个协议上的一个子集。互联网中相互通信就必须基于相同的方法
    如何通信，使用什么设备，这些都是需要一种规则，而这种规则就被称为协议
    TCP/IP协议中最重要的一点就是分层，分为应用层、网络层、传输层、数据链路层，分层是有好处的，比如某个地方需要
    修改的话则需要将整个协议替换掉，而分层的话就只需要修改所在层就行，把每个层接口修改好之后就可以自由修改每个
    层了
    应用层
      决定了向用户提供服务时的通信活动，比如电子邮箱发送，文件传输访问等，http就在该层
    传输层
      传输层对上层应用层，提供两台计算机之间的数据传输，这层的指责是保证数据在ip地址标记的两点之间进行可靠的传输，
      比如说三次握手四次挥手，在传输层有两种性质不同的协议TCP和UDP
    网络层
      网络层就是处理网络上的数据包，该层规定以什么样的路径将数据包传送到对方计算机上
    链路层
      用来连接网络的硬件部分，光纤、网卡等都属于链路层，让数据在物理媒介传输
    在通过TCP/IP进行网络通信时发送端会从应用层往下走，接收端会从链路层往上走
    比如：一个用户发送一个web页面的请求时，会从应用层发送该http请求，然后传输层为了传输方便会对该请求
        进行分割，每段报文加上序号并加上端口号，网络层接收到请求报文后增加通信目的地的mac地址，通过链路
        层发送给服务器，服务器在接收到后从链路层往上发，到达了应用层便算是接收到了请求。发送端在发送数据
        时，每一次必会加上该层所属的首部信息，接收方在接收后每一层会去掉该层的首部信息
    IP是一种协议，IP地址是节点被分配到的地址，MAC地址是网卡所属的固定地址，IP地址是可换的，MAC地址是固定的
  三次握手、四次挥手
    客户端发送一个携带SYN和随机产生一个值seq=x的数据包给服务端，表示请求建立连接，服务器收到后返回一个携带ACK=1，
    syn=1，ack=x+1的数据包给客户端，表示接收到了客户端的请求并同意建立连接，客户端收到后检查ack值是否为x+1，如果正确
    返回一个ack=1的包给服务器，完成三次握手。
    客户端发送一个FIN用于请求释放连接，第一次挥手
    服务器收到这个FIN后返回一个ACK表示接收了请求，第二次挥手
    服务器发送完最后的数据后再给客户端发送FIN报文，第三次挥手
    客户端接收到后，发送ACk给服务端，然后连接断开，第四次挥手
  三次握手是确保双方都可以进行正常的请求发送数据，四次挥手是因为在第三次挥手结束后在网络中可能还存在客户端没有接收完的数据，
  因此需要进行第四次挥手。
    ack：确认号字段是否有效，为1时有效，为0时无效
    syn：表示请求建立连接
  DNS
    DNS是跟http一样处于应用层的协议,dns负责域名到IP地址之间的解析。用户通常通过采用主机名和域名去访问计算机，
    因为字母配数字比起纯数字更符合人们的记忆习惯，而计算机对于这种地址理解起来却比较困难，因此出现了dns去进行解析，
    dns提供通过域名查找ip地址，或者通过ip地址反查找域名的服务。DNS是一个树状分布式的查询系统(根域名服务器,顶级域名服务器，权威域名服务器)，但为了提供查询效率，外围有多级的缓存。使用dns可以实现基于域名的负载均衡
    流程:
      用户主机中运行着dns的客户端
      浏览器会将url中抽出域名部分，并将这部分传递给客户端
      dns客户端会向dns服务端发送一个查阅报文，该报文中包含着要访问主机字段
      dns客户端最后会收到服务端返回的目标地址ip地址，然后传递给浏览器
      浏览器收到后会建立与该ip地址的联系，发起tcp连接
  IP地址和mac地址的区别
    ip地址表示的是网络分配的地址，mac地址是网卡所属的固定位置，ip地址其实是终点地址，它在每一次跳路由器的时候都不会改变，mac地址属于下一跳地址，在每一次跳的时候都会改变。之所以不用ip地址来替换mac地址是有好处的。就是将物理地址和逻辑地址分开，更有利于网络层和链路层协议的切换。之所以需要ip地址是因为如果只有mac地址的话，路由器需要记住每一个mac地址所对应的
    地址是哪个，全世界mac地址太多了，路由器内存是不能够进行储存的。之所以需要mac地址是因为在设备没有进行ip地址分配的时候
    需要通过mac地址去进行划分，所以这两个地址缺一不可
  TCP UDP(用户数据报协议)区别
    TCP是需要连接的，TCP相对来说更加安全可靠，只有单播功能
    UDP是不需要连接的，不可靠，不能确保数据的顺序传播和完全发送，因为UDP没有拥塞控制，一直会以恒定的速度发送，即使网络
    条件不好也不会对发送速率进行调整，因此很容易出现数据包丢失的情况，但是这种传输速度就比较快，比较适合实时性要求高的
    场景。
  点击页面链接后会发生什么事：
    先判断链接是否是ip地址，如果不是则进行dns解析，依次查找浏览器缓存，系统缓存，host文件缓存，如果没有找到就进行dns服务器获取ip解析，如果解析失败就进入错误页面，解析成功就返回ip地址
  http协议
    http协议是用于客户端和服务端之间的通信，请求文本或资源的被称为客户端，提供资源的被称为服务端
    http协议是无状态协议，不对发送过和请求过的通信状态进行保存，这是为了更快地处理更多事务，确保协议的可伸缩性
    特点： 1.灵活可拓展，
          2. 可靠传输协议，基础TCP/IP协议，尽量保证数据的传达
          3. 无状态，不对服务端客户端的请求状态记录
          4. 请求应答模式，客户端主动发起请求，服务器被动回复请求
          5. 明文传输
  Token
    token是用于解决http无状态的问题，避免每次请求都需要重新认证。
    客户端可以利用设备的mac地址作为参数传递到服务端，服务端将该token保存起来，每次进行请求的时候都进行统一拦截进行对比。
    在网络层面使用明文token是很危险的，需要跟https协议一起使用.token相对于cookie是更加安全，cookie直接将user信息进行
    存储，token一般会采用加密编码的形式。
    token可以存在localStorage、sessionStorage、vuex、redux等状态管理工具里，token可用于跨域请求，cookie不行
  JWT
    JWT由头部(header)+负载(payload)+签名构成
    头部是一个json对象表示这个token的类型，签名的算法，payload也是一个json对象，用来存放实际需要传递的数据(签发人，过期时间，生效时间),签名是对前两部分对签名，防止数据被篡改
    使用jwt不仅可以用于认证，还可以用于交换信息，可以降低服务器查询数据库的次数
  GET POST区别
    get一般用于获取页面资源，而post用于提交一个form表单，用来获取一个有结果的页面
    比如get用来获取一个html或者是一个图片，由于这些资源都是幂等的所以可以对get请求设置缓存
    post请求一般都是不幂等的，比如提交一个商品下单页面，这个是需要向服务器发起请求的，是不能设置缓存的
  http1.1
    持久连接
      为了解决http1.0每次通信都需要建立一次连接造成大量通信量的开销，http1.1提出了持久连接，就是只有当
      一方提出需要断开连接的时候才会断开连接
  cookie
    cookie的引入是为了解决http无状态，若是给http设置有状态则需要大量的内存会给服务器造成很大负担，若是
    无状态则无法对之前的状态进行保存，cookie的出现便很好的解决了这个问题，cookie技术通过在请求和响应报文
    中写入cookie来对客户端的状态进行保存
  报文结构
    报文首部 + 空行 + 报文实体
    请求报文: 请求行 + 请求头 + 实体
    响应报文： 状态行 + 消息报头 + 响应正文
    请求行：请求方法 请求路径 HTTP版本
    状态行：状态码 原因短语 HTTP版本
  分块传输编码
    一个资源量大的页面在请求资源未传输完成之前浏览器是无法显示的，可以通过将这个资源进行分块传输
    来让浏览器页面逐步显示
  发送多数据对象集合
    http采用了MIME(多用途因特网邮件扩展)机制允许邮件处理文本、图片、视频等多类型的数据
  范围请求
    下载某个很大的文件时，如果突然断网了，由于http是无状态的则需要重新下载。因此http采用了范围
    请求的方法，就是将一份资源分为多个范围进行请求
  队头阻塞
    由于http是基于请求应答的模式来进行的，报文必须是一发一收的，如果队首的请求处理太慢，会阻塞后面的请求
    解决方式: 1. http1.1 采用了并发连接的方式，对于一个域名允许分配多个长连接，相当于增加了任务队列
            2. 域名分片，HTTP 协议和浏览器不是限制并发连接数量，可以多开几个域名，将域名都指向一个服务器
  http状态码
    1xx: 信息性状态码  请求正在处理中
      101: 切换协议，就比如http切换成https时，之前的请求都会返回101
    2xx: 成功性状态码  请求处理成功
      200:请求被成功处理了，内容也被正常返回
      204(no content):请求被正常处理,但是响应报文中不包含实体主体部分
      206:表示进行范围请求,Content-Range表示请求的范围
    3xx: 重定向状态码  请求需要附加操作进行处理 (如果不做重定向可能会导致流量白白流失)
      301:永久重定向,表示资源已被分配新的uri(空间服务器不稳定,域名到期不想续费)
      302:临时重定向,表示资源不是永久移动，还有可能发生改变
      304:表示服务端资源未改变，可以直接使用缓存的资源
    4xx: 客户端错误状态码  服务器无法处理请求
      400:表示请求中存在语法错误，需修改请求内容后再次发生请求
      401:用户认证失败
      403(forbidden):请求资源访问被服务器拒绝了
      404(not found):服务器上无法找到请求的资源
    5xx: 服务端错误状态码  服务器处理请求出错
      500:服务端在执行过程中发生了错误
      503:服务器超负荷或者停机维护,无法处理请求
  代理
    代理是一种拥有转发功能的应用程序，扮演着客户端和服务器的中间人，将客户端发送的请求转发给服务器，并将
    服务器的响应转发给客户端。
    代理有缓存代理、透明代理(不对报文做任何加工的代理)、非透明代理
    正向代理
      正向代理是代理客户端，由代理服务器访问目标服务器。这个可以用于解决不能访问目标服务器的问题，比如访问谷歌，也可以加速访问资源，正向代理可以隐藏客户端的信息,vpn也是利用了正向代理的原理
    反向代理
      反向代理是代理服务端，由代理服务器来接受internet上的请求，然后将请求转发给内部网络的服务器。并将得到的结果返回给客户端，反向代理中客户端并不知道自己访问的是一个代理。一般设置反向代理后需要修改DNS让域名解析到代理服务器IP
      使用这个可以确保内网的安全，阻止web攻击。  负载均衡，通过反向代理服务器来优化服务器的负载
  no-cache: 不缓存过期的数据
  no-store: 不进行缓存
  If-Match: 只有这个值跟Etag值匹配上时,服务器才会接受请求
  If-None-Match: 只有这个值没有跟Etag匹配上，服务器才会接受请求
  If-Modified-Since: 只有在设置的时间后资源发生了更新，服务器才会处理请求，如果没有发生更新则返回304
  Last-Modify: 资源最后修改的时间
  User-Agent: 用于传递浏览器的种类
  Etag: 资源唯一标示符，由服务器分配，分为强Etag和弱Etag，强Etag是无论资源发生了多么微妙的变化都会变化，弱Etag是资源发生了根本性的变化才会变化
  Location: 配合URI进行重定向
  Allow: 能支持的HTTP方法
  http1.1 默认连接为持久连接，若想在http1.0持久连接则需要设置connection：keep-alive
  http缺点: 不安全，明文不加密容易被窃听，无法验证内容的完整性，内容可能被修改。
  网关
    网关是转发其他服务器通信数据的服务器
  隧道
  浏览器缓存机制
    service worker
      当处于离线或弱网状态时,我们无法访问一些资源，可以通过service worker进行缓存。
      service worker只能运行在https，Service Worker可以监听所有客户端发出的请求，然后通过service worker去代理，想后端服务器去发送请求使用缓存，service worker会监听发起的请求  https://alienzhou.github.io/fe-performance-journey/1-cache/#_5-push-cache
    push cache
      这个是http2的push功能带来的，在请求一个资源时，服务端也会给你推送一些其他资源，这次缓存存活时间比较短，只会被使用一次
    浏览器缓存就是浏览器保存http获取的资源，然后储存在本地的一个行为，缓存的资源储存在内存或者磁盘中，使用频繁的一般存放在内存中，但是内存的空间是有限的，一般比较大的就会存放在磁盘中，缓存分为强缓存和弱缓存
    强缓存：不会想服务器发生请求，由expires和cache-control控制
    expires：是一个绝对时间，在绝对时间到之前资源依然有效，但是这个受限于本地时间，修改本地时间可能会造成资源有效时间错误
    cache-control：是一个相对时间，利用max-age来判断
    cache-control的优先级大于expires
    协商缓存：强缓存失效后，浏览器携带缓存标示向服务器发起请求，由服务器根据缓存标示来判断是否使用缓存，协商缓存生效后会返回304和not modify，失效想服务器请求资源，由last-modified和Etag来控制
    last-modified： 浏览器在第一次访问资源时，服务器会给相应头部添加last-modified，值就是这个资源的最后修改时间，下次再访问时，浏览器检测到有last-modified，于是在头部添加if-modified-since，值是last-modified的值，然后这个值会跟服务器的最后修改时间进行比较，如果没有变化则返回304，直接从缓存中读取，如果改变了，则返回资源。  弊端： 1. 如果本地打开了缓存资源，即使没有修改也会影响last-modify的值。 2 last-modify的值是以秒为单位，如果在很短的时间修改了则不会被察觉。
    Etag: 这个是服务器相应请求返回的对资源的唯一标示，只要有资源变化就会重新生成，下一次请求时会将Etag放进请求头的if-not-match里，如果跟服务器上资源一致，则会返回304并使用缓存，否则会使用服务器资源


  跨域： 指的是由于浏览器的同源政策，浏览器不允许一个域脚本加载访问另外一个域，同源就是两个页面具有相同的协议、端口号、域名。这三者任意有一个不同都不属于同源。跨域请求是可以正常发出，但是返回结果会被浏览器拦截。
    解决方案: 前端方面：：是利用了script、img、link等标签可以加载跨域资源的原理。缺点是只支持get请求，不支持post
                     document.domain：只要设置相同的domain，两个页面就可以实现跨域通信
             后端方面：cors(跨域资源分享)，w3c的标准，属于跨域请求的根本解决方法，cors主要是通过设置
                        Access-Control-Allow-Origin来进行的，如果浏览器检测到相应的设置就可以运行
                        ajax进行跨域的访问
             nignx代理跨域： 由于服务器之间不存在跨域，所以可以先将请求发送了同源服务器，再通过服务器去向目标服务器发起 
                            请求，数据返回后再返回给浏览器。

webSocket
  webSocket是一种通信协议，可以解决http通信只能由客户端发起，这个协议可以建立无限制的全双工通信，适用于双向通信。
  webSocket复用了http的握手通道，在建立其http连接后，需要完成一次握手操作去实现webSocket通信，这里用到了http的
  upgrade首部字段，告诉服务器通信协议发生改变

https
  与ssl(安全套接层)和TLS(安全传输层协议)结合的http被称为https  
  https与http相比会更慢，除了和tcp连接发送http请求相应之外，还要进行ssl通信。第二点就是ssl还在客户端服务端都需要进行加密和解密处理，通过这种没有根本性的解决办法，只能使用ssl加速器这种硬件来改善该问题。
为什么不一直使用https： 1. https机密资源需要消耗更多的cup和通信资源，如果每次都消耗那么多资源，能够处理的请求会随之减少。所以只会在一些比较敏感的资源上会进行https通信
                     2. https证书需要花钱，这点对于个人网站之类的就比较不划算。
 SSL
  通常HTTP和TCP直接通信，当使用了SSL时，HTTP先跟SSL通信，SSL再跟TCP通信
  ssl采用一种公开密匙加密的加密处理方式
 共享密钥加密(对称密钥加密)：使用同一把密钥加密解密的方式，需要将密钥发送给对方，加密后的数据发送给对方，但是通信被窃听的话就失去加密的意义了。
 公开密钥加密: 使用一把公开密钥和一把私有密钥进行加密，公开密钥大家都可以获得，对方采用公开密钥进行加密，然后自己采用私有密 钥进行解密，这样就不用担心密钥被别人窃取。
 https采用混合加密机制
  共享密匙加密相对不安全，公开密钥加密相对处理太慢。因此https采用了混合加密，采用两者结合。使用公开密钥加密的方式将密钥发送给对方，然后再采用共享密钥的方式来进行数据传送 
ca证书
  公开密钥加密方式还是存在一些问题的，比如无法确定公开密钥本身就是货真价实的公开密钥，在发送密钥的途中，可能会被攻击者攻击替换公开密钥，这样便无法验证这密钥是否是真正的密钥。为了解决这些问题可以使用数字证书认证机构和其机构颁发的公开密钥认证证书。
  数字认证机构的业务流程： 首先服务器的运维人员会想该机构提出公开密钥的申请，数字机构在判明申请者的身份之后会对已申请的公开密钥进行签名，然后分配这个已经签名的公开密钥，并将公开密钥放入公开证书并绑定在一起
XSS(跨站脚本攻击)
  指存在安全漏洞的网站注册用户浏览器内运行非法的html或者js进行的攻击，动态创建的html可能隐藏着安全隐患。
  xss分为三种基于dom、反射型、储存型
  基于dom是通过脚本来对页面对dom对象进行操作从而达到攻击效果
  反射型是在恶意网站通过注入了能获取用户隐私信息的脚本来获取用户的隐私，比如在一个网站上的form提交，通过恶意脚本在用户提交时获取用户的信息。
  储存型是服务器会将用户的数据储存在服务端，攻击者通过将一些恶意脚本写入输入的数据中，然后其他人访问这些数据时这些恶意脚本就会执行，达到获取用户信息的效果
  1. 通常xss都是利用虚假的表单骗取用户的个人信息
  2. 利用脚本获取用户的cookie值，攻击者借用用户的身份发起恶意请求
  解决: 1. 检查输入： 对用户输入的一些特殊字符进行检测，比如script标签进行编码或者过滤
        2. httpOnly: 设置这个让用户无法通过脚本获取cookie
CSRF(跨站请求伪造)
  通常是借用用户的cookie来发起恶意请求。
  流程： 用户登录网站A后，会产生cookie信息并返回给浏览器。然后用户未退出网站A，打开另外一个tab页进入恶意网站B。网站B便会利用用户的cookie信息发送一些请求给网站A，就比如：用户A在银行b有一个账户，登录进这个银行b的网站后，攻击者恰好也有这个银行的账户，诱导用户进他的网站c后，借用用户A在银行b的cookie信息在网站c发送一些汇款请求给攻击者的账户，这样就达到了攻击的效果。(之所以可以从c获取a的cookie是因为html的src可以进行跨域请求，类似于原理)
  防御:
    1. 通过设置token的形式，攻击者不能获取用户http请求中的token，在服务端设置一个拦截器，如果token不正确便被当成csrf攻击
    2. 验证http referer字段，这个字段记录了用户请求的来源地址，如果来源地址不是那个网站地址，则被当成csrf攻击，当然这样并不一定安全，在一些老旧浏览器中黑客还是可以修改这个字段的。
    3. 验证码，对一些存在安全隐患的操作通过验证码来通知用户是否同意
  chrome的sameSite：用于限制第三方cookie，从而减少csrf的风险
      可以设置了strict，lax，none三个属性
      strict： 最为严格，只有当前url的时候才会带上cookie，这个虽然比较安全，但是体验不好，比如从爱奇艺网站点击进一个视频准备观看，还是需要重新登录获取登录状态
      lax：限制了部分，导航到目标网址只有三种情况会发送，a标签，link标签，get表单
      none：显式关闭sameSite属性
  http/2
    头部压缩
    多路复用
  
SQL注入
  SQL注入就是将SQL语句改写成开发者意想不到的形式进行攻击，比较常见的例子就是对SQL语句进行字符串拼接，直接使用用户输入的文字作为变量，这样用户只要在中间进行修改，添加一下delete之类的关键字，便可以达到SQL注入的效果。解决方法就是过滤用户输入的特殊字符，禁止使用字符串拼接sql语句
js
  dom事件流:事件捕获最先发生，然后实际的目标元素接受到事件，最后一个阶段是冒泡
    捕获:从最外层dom结构沿dom树依次向下触发，直至到达触发事件节点
    冒泡:从触发事件节点沿dom树依次向上触发，直至到达document对象 
      使用场景:一个购物车列表中，点击列表item的文字会冒泡到最外层触发item的点击事件跳转到item的详情页面。
             阻止冒泡就是点击旁边的删除按钮不想跳转到item的详情页面
    可以通过addEventListener添加事件处理函数，addEventListener可以传入三个参数：事件名，事件处理函数，布尔值(true表示在捕获阶段调用事件处理函数false表示在冒泡阶段处理程序)
    js中可以通过stopPropagation停止事件继续传递，vue中可以使用stop修饰符@click.stop

  事件循环机制
    这个是js用来处理事件执行顺序的一种机制，js遇到同步任务会加入主线程执行，遇到异步任务时会将该异步任务加入队列中，
    待主线程中任务执行完毕后再从异步任务队列中出列异步任务到主线程执行，在执行过程中如果遇到了异步任务则会继续加入
    到异步任务队列，在执行完主线程任务完后再继续获取异步任务队列任务，如此循环直至主线程和异步队列任务都执行完为止。
    这里的异步任务队列也是分为微任务队列和宏任务队列，微任务有promise.then 宏任务有setTimeout,setInterval,setImmediate,在执行完主线程后会先执行微任务在执行过程中遇到异步任务会加入相应的队列任务中，在微任务队列
    清空后会开始执行宏任务，在执行过程中遇到异步任务会加入相应的队列任务，执行完这个异步任务会检测是否存在微任务，
    如果存在则执行微任务队列，则继续执行微任务队列任务，如果没有则继续执行宏任务队列任务直至宏任务微任务队列都清空
    宏任务: setTimeout setInterval requestAnimationFrame setImmediate
    微任务: promise.then
  为什么要区分宏任务和微任务
    为了可以插队,如果不区分宏任务和微任务就无法在下一次事件循环之前进行插队，处理异步事件的优先级

  原型和原型链
    每个对象创建时都会有一个与之相关联的对象，这个对象称之为原型，当查找一个对象的方法或者属性时，如果在这个对象上
    不存在就会在对象的__proto__上查找，这个__proto__指向的就是对象的原型，当在对象的原型上找不到时会沿着对象原
    型的原型去查找，一直到null为止，这个查找的过程就叫原型链。原型链是ES的主要继承方式，同一个构造函数创建的实例
    都共享着同一个原型，通过原型可以达到给每个实例添加一个统一的方法

  作用域
    作用域是一套用来规定如何储存和查找变量的规则

  闭包
    闭包指的是引用了另一个函数作用域的函数，闭包的原理是利用了作用域链的特性，在当前作用域找不到该变量时会去沿着
    作用域链查找。闭包可以使用外部函数变量，可以利用闭包做到隐藏变量，防止影响全局变量的效果，每个函数在创建的时候
    都会有个scope属性用来保存上一级的作用域
    闭包会保留它们包含函数的作用域，因此比其他函数更占内存，过度使用闭包容易造成内存泄露

  instanceof
    通过判断对象实例的原型链上是否存在与构造函数的prototype相等的原型

  new
    1 创建一个新对象
    2 将对象的原型指向构造函数的原型
    3 执行构造函数的代码并将this指向新对象
    4 返回这个对象

  es5和es6继承
    es5采用函数继承的方式，以prototype来实现继承，es6采用class继承的方式，使用extend来实现继承
    es6的继承方式实际是es5的语法糖，不过语法上可以支持正式的面向对象编程，但是实际背后也是原型和
    构造函数的概念
  面向对象编程
    就是将一个问题把它抽象成对象的概念，就是说这个这个问题有哪些对象，给这些对象赋予一些属性和方法，然后
    让这些对象去执行自身有的方法去解决这个问题
  ES6
  观察者模式和发布订阅模式
    发布订阅模式是一种一对多的依赖关系，当一个对象状态发生改变时，所有依赖它的对象都将得到状态改变的通知
    观察者模式中就是观察者和目标直接进行交互
    发布订阅模式是订阅者和发布者互不干扰，通过调度中心进行交互，发布订阅模式和观察者模式实现原理虽然雷同，
    但是使用这种方式可以抽离出调度中心单独成一个文件，可以对一系列的订阅事件进行管理，这样相比观察者模式
    中的事件更加方便维护
    优点: 1. 对象之间解耦合 缺点： 1. 创建订阅者要消耗内存
css
  BFC
    bfc直译为块级格式化上下文，是页面独立的一块渲染区域，有着独特的渲染规则。其中的元素布局不受外界的影响，并且
    在一个bfc这种，块盒和行盒都会垂直沿着父元素的边框排列
    在bfc中内部的box会在垂直方向一个接着一个地放置，垂直方向的距离由margin决定
    bfc是一块独立的区域，不受外部影响
    计算bfc高度时，浮动元素也参与计算
    开启bfc：
      display不为none
      position不是static或者relative
      overflow不是visible
    作用：
      1. 避免边距重叠
      2. 自适应两栏布局
      3. 清除浮动
  居中
    水平居中:
      块级:margin: 0 auto;
      行内:text-align:center;
      块级和行内:display:flex; justify-content:center;
               使用position
    垂直居中:
      块级:.parent{position:relative;}child:{position:absolute;top:50%;transform:translateY(-50%)}
      行内:设置line-height高度与height一致  
    水平垂直:
      利用flex布局:justify-content:center;align-items:center;
  flex
      css一种局部方式
      常见属性有flex-direction(定义布局方式),flex-wrap：定义是否换行
              justify-content:主轴的对其方式，align-items:交叉轴对齐方式
              align-content：多个轴线的对齐方式
  css实现长宽比例
    这个是利用padding-top的百分比是根据容器的width来计算的，如此一来就很好的实现了容器的长宽比
    <div class='box'></div>
    .box{
      position: relative;
      height: 0;
      width: 100%;
      padding-top:75%;
    }

  清除浮动
    额外标签
    bfc
    伪元素
  边距重叠
    两个块级盒子的垂直边距会重合，它们的边界宽度是边界临界值的最大值
    解决的办法是创建bfc，使用padding代替
浏览器
  回流重绘
    回流是指dom元素的尺寸或者布局等属性发生的改变引起了元素的重新构建被成为回流，应该尽量避免回流，回流会影响页面性能
    重绘是指元素的外观、风格等发生改变，不影响布局的被称为重绘
    回流必定会引起重绘，重绘不会引起回流。 
    引起回流的操作：增添或删除dom、元素位置改变、内容改变
    引起重绘的操纵：改变字体颜色、背景颜色
  如何减少回流重绘
    浏览器的帮忙:浏览器会维护一个队列，把所有可能引起的回流和重绘放入这个队列，等到队列中的操作达到了一定的数量或者到了
    一定的时间间隔，浏览器就会进行一个批处理
    通过className去一次性修改样式
    避免频繁访问直接计算后的样式，将计算值缓存下来
    对于需要多次添加的子元素，先将这些子元素使用虚拟dom的形式克隆下来，然后再添加上去
  一个页面从输入url到页面加载完成，这个过程中都发生了什么
cookie  session localStorage sessionStorage的区别
  cookie是存在于客户端的，session是存储在服务端的。session在客户端是不可以访问的。
  使用session对服务端负担比较大，相比于cookie更加的安全，session是不能区分路径的，所有的session都可以在任何一个地方访问
  到，而cookie中如果设置了路径参数，那么不同路径下的cookie相互是访问不到的。
  作用不同，cookie用于储存客户端和服务端之间的信息传递，localStorage用于储存本地数据，相比cookie存放量更大，
  sessionStorage相对于localStorage来说更安全，因为sessionStorage仅在当前会话有效，关闭页面或浏览器被清除后
  sessionStorage会被清除

进程、线程
  进程是资源分配的最小单位，线程是cpu调度的最小单位。
  浏览器是多进程的，如果是单进程的话，其中一个页面如果崩溃了，那就影响了整个浏览器，对用户体验不好。
  浏览器进程、插件进程、GPU进程、渲染进程
  一个页面中是多线程的，主要有渲染线程：用于页面的回流重回，
                  定时触发器线程:通过这个来计时触发定时器任务的，
                  事件触发线程：用于控制事件循环，
                  js线程：用于运行js代码，
                  异步http请求线程：用来检测异步请求是否状态变更
  js线程和渲染线程是互斥的，因为js会操作dom，如果修改了元素属性会导致渲染引擎前后渲染结果不一样。也需要避免js引擎进行太久
  的计算，导致页面渲染不连贯。
  web Worker是js引擎向浏览器申请开一个子线程的形式，js引擎线程与worker线程通过postMessage API来通信

进程之间通信的方式
  1.管道
  2.报文队列
  3.共享内存
  4.信号
线程之间通信的方式
  1.锁机制
  2.信号量机制
0.1 + 0.2 != 0.3
  由于js采用的是ieee 754进行数字存储，采用这种存储方式在计算中会发生两处精度缺失。
  第一处是在将小数转化了二进制时，由于有效数字只能存储52位，而0.1和0.2保存下来时无限循环
  小数，所以会对超出部分进行取舍处理，这样就导致了第一处的丢失。第二个部分就是对阶计算，要将
  小的指数转化了大的指数，必然会把52位有效域最右边的给挤出去，挤出去的部分也会发生舍入，这样
  就发生了进一步的丢失。这样就导致了0.1 + 0.2 != 0.3
解决方式：
  1. 将小数化成整数，但是对大数支持依然不好
  2. 采用第三方库, Math.js big.js
ieee 754存储方式
  第一位储存符号位
  2-11位储存指数域  【-127，128】
  3-64位储存有效数字位

移动端
  适配移动端

301、302
  301 永久重定向，表示资源已经不可访问了。302 临时重定向，表示资源还在，只是临时从a跳到了b。
  尽量使用301跳转，使用302重定向很容易被搜索引擎误认为是利用多个域名指向同一个网站，那么网站很容易
  被认为是‘利用重复内容来干扰搜索结果的网站排名’而被封掉，因为网站使用302定向到另外一个网站时，搜索
  引擎也会将另外一个网站的搜索结果贡献给这个网站，从而提高这个网站的搜索排名

react 17 vs vue3

写法上是相似的，不过在底层实现是没有关系
hooks函数每次更新都会执行
vue是通过响应式和生命周期函数来进行更新

vue3 template exploer

react自由度更高，比较考验开发者的编程能力，vue中很多都被封装好了，比如v-if,v-model等
vue：根据组件划分，组件之间通过响应式通知，组件内部通过vdom计算diff
vdom 用js的object来描述dom节点，跨端
react没有响应式，完全是通过diff
模版模版渲染方式不同，vue中是通过扩展的html语法进行渲染，react是通过jsx渲染模版

react fiber(对核心算法的一次重新实现)
1. 任务可以切开 利用空闲时间计算
2. diff可以中断
  在react中使用setState更新页面的时候，react会遍历应用的所有节点，计算出差异，然后再更新ui。在这个过程中是一气呵成的，如果页面元素很多就容易出现掉帧的现象。react fiber的出现就是为了解决这个问题。
  react fiber在进行diff计算的时候会生成一颗fiber树，fiber树在首次渲染的时候会一次过生成，在后续需要diff的时候，会根据
  已有树和最新的虚拟dom信息生成一颗新的树，这颗树每生成一个节点都会将控制权交给主线程，去检查有没有优先级更高的任务需要进行，如果没有则继续构建树，如果有就会舍弃正在生成的树，在空闲的时候再重新执行一遍，在构建过程中会将需要更新的节点保存在
  列表中，之后会将需要更新的节点一次批量更新

react框架内部分为三层：
  1. virtual dom层
  2. reconclier层，负责调用组件生命周期方法，进行diff运算
  3. renderer层，根据不同的平台渲染出相应的页面，比较常见的是reactDom和reactNative

懒加载和预加载
  懒加载也叫延迟加载，是当视图滚动到相应图像时才会对图像进行加载，利用的原理是先将页面上的img的src属性设置为空字符串，
  真实路径存放在dataSet里面，根据判断懒加载图片是否进入可视区域，如果在可视区域就将src设置为dataSet的值

vue中做了静态标记，静态的不会采用diff

js开启多摄

rn运行原理

react运行在小程序
  react在web上的运行、渲染、节点操作并不是与dom进行强绑定，而是通过react-reconciler来进行实现的。react-reconciler通过描述react如何创建一个dom、删除节点、更新dom阶段。因此小程序也是可以通过react-reconciler去进行实现，但是有一点不同的是小程序没有提供创建、删除、更新视图的api，但是小程序可以通过数据驱动模版渲染视图，因此我们可以通过react-reconciler去创建一个VNode，然后构成一个node tree，将tree data挂载到小程序页面，由这个数据来驱动模版渲染视图。

  encodeURIComponent、encodeURI
    encodeURI是用来对url进行编码，encodeURIComponent是对url的参数进行编码
  

客户端和服务端长连接的几种方式（前端如何实现即时通讯？）
  1. 轮询
      短轮询: 通过客户端每隔一段时间去服务器查询是否有新消息，保持数据的同步，实现的话可以通过js的setTimeout函数去发送请求
        优点：可以实现基础的数据更新，逻辑简单
        缺点：大多数请求是无效请求，对服务端的压力很大
      长轮询: 客户端向服务器发送ajax请求，服务器接到请求后保持连接，直到有新消息或者超时才返回响应信息并关闭连接，客户端
      处理完响应信息后再向服务器发送新的请求。这个实现可以通过在http请求头上设置connection值为keep-alive，服务器接收到这个信息就会知道这是一个长连接。
        优点：实时性好，并且不会频繁的请求
        缺点：连接创建销毁操作比较频繁，服务器维持着连接比较消耗资源
  2. webSocket
      webSocket是全双工通讯，无论是客户端还是服务端都能主动向对方发起响应，服务器具备了真正的推送能力

http请求头添加connection值为keep-alive实际上是同时发送多个request，接收多个response，也就是说一个request只能有一个
response，建立websocket是通过设置connection为upgrade，设置upgrade为websocket

  跨窗口之间通信
    比如QQ音乐中，播放页是另外的一个页面，当在首页点击播放一个音乐的时候，播放页要播放点击的这个音乐，因此需要实现跨窗口通信
    1. localStorage： 一个窗口更新localStorage,另一个窗口监听window的storage对象来实现通信。(localStoage需要同源窗口才能共享)
     // 一窗口
      localStorag.setItem('a',123)
     // 另一窗口
      window.addEventListener("storage",(e)=>console.log(e))
    2. postMessage
      通过这个可以安全地实现window对象之间的跨域通信，不过两个窗口必须建立联系,可以通过window.open，iframe
    3. webSocket
      所有的websocket都监听同一个服务器地址，利用send发送消息，利用onmessage获取消息，不仅能跨窗口，还能跨浏览器

  前端模块化
    模块化:将一个复杂的程序根据一定的规则封装成不同的块，并进行转合在一起
    模块化的好处：1.避免命名冲突
                2.更好的分离
                3. 更高的复用性，更高的维护性
    引入多个script的问题： 1.需要发送多个请求 2.依赖模糊，不了解他们之间的依赖关系 3.难以维护
    模块化规范
      commonJS
        node应用由模块组成，采用commonJS模块规范，每个文件都是一个模块。这个加载是同步的，只有加载完成才能进行后面的操作，由于node.js主要用于服务器编程，模块文件一般都已经存于本地硬盘，所以加载起来比较快，不能考虑非同步加载的方式
        语法： module.exports或exports.xxx  引入: require('')
        这个加载机制是输入的值是被输出的值的拷贝，这个模块具有缓存，第二次使用是不会重新加载的
      AMD(最具代表性的是requiresjs)
        如果是浏览器环境，要从服务器加载模块，这时就必须采用非同步模块，因此浏览器一般使用AMD规范，使用时需要导入实现
        了AMD的库后才能正常使用
        语法: define()   引入require
      CMD(sea.js)
        专门用于浏览器端，模块的加载是异步，模块使用时才会加载执行
      ES6模块化
        es6的模块化设计思想就是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。commonJS和AMD模块
        都只能在运行时确定这些东西，只能作为模块顶层的语句出现
      区别： 1.es6 输出的是模块的引用，commonJS输出的是一个值的拷贝。
            2.commonJS是运行时加载，es6是编译时输出接口，循环加载的话会返回当前已执行的结果
      总结： commonJS规范主要用于服务端编程,加载模块是同步的，这并不适合在浏览器环境，因为同步意外着阻塞加载，浏览器
            资源是异步加载的,因此有了AMD、CMD解决方案。AMD是依赖前置，方便知道依赖模块是谁，立即加载。CMD是就近依赖
            需要使用把模块解析一遍才知道依赖了哪些模块。AMD和CMD最大的区别是对依赖模块对执行时机处理不同，AMD在加载模块
            完成后就会执行该模块，CMD在加载完所有模块，在主逻辑中遇到该模块才会执行，这样模块与书写模块执行顺序是完全一致
            的。

  for in for of
    for in是key,适用于数组和对象
    for of是value，适用于数组
  array.reduce

项目
  ios和android时间
  解决ios延迟300ms
    300ms主要是因为在ios中由于用户可以进行双击缩放，在单击后会在300ms内再次点击会被认为是双击缩放。
    可以通过使用fastClick库去解决，这个是检测到touchend事件后会通过dom自定义事件立即模拟一个click事件，
    并把浏览器在300ms之后到click事件阻止掉
前端渲染10000条数据
  可以进行分批渲染，每次渲染部分dom。可以通过使用requestAnimationFrame来实现每16ms刷新一次。可以使用文本
  片段createDocumentFragment，因为文档片段存在与内存中，并不在dom树上，所以将子元素插入文档片段时不会引起
  页面回流。  每一次插入dom都会重新重绘页面，一种常见的方法就是将创建的元素写到一个字符串上，然后一次性写到innerHTMl,
  这种使用对上面插入快很多，但是构建字符串灵活性比较差，很难符合创建各种各样对dom元素，创建dom
requestAnimationFrame
  这个可以保证回调函数在每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象
  cpu节能: 使用setTimeout实现的动画，当页面被隐藏或最小化时，setTimeout仍然在后台执行动画任务，由于页面处于
          不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。使用requestAnimationFrame则完全不同，
          当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停。
  函数节流: 在高频率事件中，为了防止在一个刷新间隔内发送多次函数执行，使用requestAnimationFrame可保证每个刷新
           间隔内，函数只执行一次，因为一个刷新间隔内函数执行多次是没有意义的，显示屏每16.7刷新一次，多次绘制也
           不会在屏幕中体现出来

router原理

讲讲 viewport 和移动端布局

浏览器渲染过程
  解析html为dom树，css为cssom，然后将css树和dom树结合生成渲染树，当浏览器遇到一个script标签时会停止dom树的构建，
  直到脚本完成执行，然后继续构建dom，如果js有对cssom的操作，浏览器就会延迟dom树的构建和脚本的执行，直到cssom完成
  建后再进行执行脚本和构建dom，因为不完整的cssom是无法使用的，js只能操作完整的cssom。等到cssom和dom构建完成后，
  会进行构建渲染树，会从dom树的根结点开始遍历，从cssom中找到相应的样式并应用。然后渲染树完成后会对渲染树进行页面
  布局，确定每个节点的位置，然后交给ui后端组件的去进行绘制。
css动画和js动画的差异

vue react区别
  1. 设计思想
      vue使用的是可变数据，react更加强调数据的不可变。
      vue中使用的数据劫持的方法，能精确知道数据的变化，vue中数据改变通过响应式来通知相应组件，组件内部通过vdom的diff算法来进行更新，react则是直接通过diff算法进行的，不过react的diff中加入了fiber优化。
  2. 组件写法
      react推荐的是all in js，就是把html和css都写进js中，vue推荐的是template的单文件组件，即html、css、js
      都写在一个文件里。
  3. react的自由度更高，vue更加简单易用，很多api都被封装好了，v-if，v-for，computed之类的
三栏布局、两栏布局
  两栏布局: 1.float + overflow(BFC) 2. float + margin-left 3. flex + width + flex:1 
  三栏布局: 1. float + overflow(BFC) 2. flex

toString
  这个会获取this对象的class属性的值，这个属性表明来该对象的类型。然后将该值与[object ]拼接

兼容性问题
  ios，android 时间显示问题
  click延迟300ms，使用fastClick
  fixed定位问题，ios软键盘弹出会影响fixed布局，使用iscroll库可以解决这个问题
vuex和localStorage区别
  1. vuex存储在内存，localstorage存储在本地
  2. vuex存储空间取决于可用内存和浏览器的限制，localstorage有个默认的大小，超出则需要用户同意增加空间
  3. vuex无法跨页面，localstoage可用在同一域下共享
  4. 需要响应式数据时需要使用vuex来实现，localstorage时刷新页面后依然可以获取到数据时使用的

类的继承

异步加载js
  为了加快首屏响应速度
  async
    加载脚本不会阻塞页面的渲染，先加载完先执行，一般用于独立脚本
  defer
    defer不会阻塞页面，和加载dom并行加载，需要等到dom解析完毕才执行，根据文档顺序进行加载，所以在应用中一般是用于
    脚本的相对执行顺序很重要的时候
  script
    最稳妥的方式，没有兼容性问题，没有白屏问题

两列等高布局

animation
  transition缺点: 1. 只能定义开始状态和结束状态，不能定义中间状态
                 2. 需要事件触发，没法在网页加载时发生
                 3. transition是一次性的，不能重复触发
                 4. 只能定义一个属性变化
  animation就是为了解决这些
    animation需要指定一个周期持续事件和动画效果的名称，还可以指定动画播放的次数
    可以使用@keyframes来定义动画的各个状态,可以同时定义多个属性
css动画和js动画优缺点比较
  js动画优点: 1. js动画控制能力很强，开始暂停终止都可以做到的
             2. js动画兼容性更好
        缺点:1.js动画容易引起丢帧
            2. 代码复杂度高于css动画
  css动画优点: 1. 浏览器可以对动画进行优化，浏览器使用requestAnimationFrame类似的机制
              2. 强制使用硬件加速(通过GPU来提高动画性能)
        缺点: 1. 运行控制能力较弱
canvas svg
  canvas是标量图，放大或改变尺寸会失真，逐像素进行渲染，依赖于分辨率，适合游戏。canvas里绘制的图像不能被引擎抓取，
  一旦绘制完成就不会受到浏览器关注，需要通过一个图片跟随鼠标事件，canvas.onmouseover = function(){}
  svg是矢量图，放大不会失真。适合大型渲染区域的应用程序，比如地图啥的。svg支持事件绑定,svg是通过标签来实现
性能优化
  1. 图片懒加载，预加载
  2. 启动缓存
  3. cdn
  4. 减少http请求:对一些经常使用的get请求进行缓存，合并静态资源，防抖节流
  5. 减少操作dom，减少回流重绘
  6. 减少文件体积:压缩js、css，合成精灵图，图片转换为base64
  7. webpack: 1.对路径进行resolve 2.使用happypack开启多线程loader转换 3.使用tree-shaking
  

@import link区别： link无兼容性问题，@import低版本不支持，@import在页面加载完被加载，link引入css被同时加载，所以网速慢的话会出现开始没有样式，link可以js控制，@import不能js控制，link是html代码，@import是css代码，dom不能控制。
@import好处是如果有很多css文件，下载多个文件比较浪费，使用@import可以将多个css合并成一个
                  
样式权重
  important > 行内样式 > id选择器 > class选择器、属性选择器、伪类选择器 > 标签选择器
  权重相同的，以后出现的为最后规则，权重不同是以权重大的为规则
单页面和多页面
  单页面
    单页面是只有一个web页面的应用，每次跳转只刷新局部资源，公共资源仅加载一次。
    单页面路由的实现原理是切换url，监听url变化，从而渲染不同的页面组件，主要方式有history和hash
    优点: 1. 页面切换快：每次页面跳转时并不需要处理html文件请求，这样就节约了很多请求时间
    缺点: 1. seo差，搜索引擎是通过html的内容去进行排名的，而单页面的内容都是靠js渲染生成的，搜索引擎不认识这部分内容，
            所以也给不到一个好的排名
          2. 首屏时间慢：首屏需要请求一次html，还要发送一次js请求(一般用来获取数据),两次请求回来首屏才会展示出来
    数据传递： url，localStorage，vuex，redux等
  多页面
    多页面是有多个页面构成，每次跳转都是返回一个新的html
    优点：1. 首屏时间快，只需要请求一个html
          2. seo效果好，直接返回html利于seo
    缺点：1. 页面切换慢：每次跳转都需要向服务器请求一次html，每次都需要加载所有资源，很不利于用户体验
    数据传递： url传参，cookie，localStorage
前端路由、后端路由
  前端路由好处: 1. 记录当前页面的状态   2. 可以使用浏览器的前进后退功能

hash history
  history:不带#的路由一般是history路由
    改变路由 通过history.pushState、history.replaceState来
    监听路由 window.addEventListener('popState',(e)=>{})
    在页面上的路由跳转通常是通过history的api进行跳转，并不会向后端发送请求，但是如果从浏览器地址栏输入一个地址或者刷新页面的话会向后端发起一个get请求的(因为js不能监听bom变化),如果后端路由表没有做相应的配置的话页面会显示404
    优点: url不带#号，更加优美
  hash：浏览器不会对#号后面对路劲对服务端发起路由请求，前端router库通过监听url中hash的变化，然后渲染不同的内容，不向服务器发送请求，不需要服务端的支持
    改变路由 通过window.location.hash属性获取和设置hash值
    监听路由 window.addEventListener('hashchange',(e)=>{})
    优点: 兼容性高，不需要后端配置
  react-router路由是采用history库去实现的

ts interface type

babel

cors跨域原理
  cors需要浏览器和服务端一起支持，浏览器一旦发现ajax请求是跨域请求，会自动添加origin,服务器会根据这个字段觉得是否同意
  本次请求。
  浏览器将cors请求分为简单请求和非简单请求
   简单请求
    简单请求是请求方法为head、get、post，http头信息不超过accept、accept-language、content-language、content-type等这几种就为简单请求。浏览器对于简单请求会在请求头部加上一个origin字段，origin表示本次请求
    来自哪个源，如果不在origin指定的源中，服务器会返回一个正常的http，不过这个http是不包含access-control-allow-origin的，因此会抛出跨域错误
   非简单请求
    不属于简单请求的就为非简单请求，非简单请求在正式通信之前会先进行一次http查询请求，称为预检请求。浏览器会先询问
    服务器，当前网页是否在服务器的许可名单之中，以及可以使用哪些http头信息字段，只要得到肯定的答复，浏览器才会发出
    正式的xmlHttpRequest请求，否则就报错
js隐式转换

let const var

85

按需加载

async 

前后端数据的交互方式
  http协议
  接口
  jsonp

垃圾回收机制
  1. 标记清除
    当进入环境时，会将环境里的变量标记为进入环境，然后当变量离开环境时，会标记为离开环境。垃圾收集器会给运行时存储在
    内存中的所有变量都加上标记，然后会去掉运行环境中的变量以及被环境中变量引用的变量的标记，然后所有带标记的变量就会
    被视为需要进行清除的变量，垃圾收集器会销毁那些带标记的值并回收他们的内存。
  2. 引用计数
    垃圾收集器会对每个变量的引用次数进行记录，如果被变量引用就加一，如果别变量取消引用就减一，当引用次数为0时，就会
    对该变量进行清理。不过这种方式遇到循环引用的话是无法清除的。需要使用标记清理来对循环引用进行清除
V8引擎垃圾回收机制
  v8将内存分成了新生代和老生代，新生代中的对象存放存活时间比较短的对象，老生代中存放存活时间比较长的。
  新生代主要使用scavenge进行管理，将内存平均分成两块，处于活跃状态的称为from空间，处于闲置状态的称为to空间。
  将新对象都分配到from中，在from中快要占满的时候会将from中存活对象复制到to中，然后将from清空，此时调换from和
  to的空间。如果一个对象经历了两次从from到to，那么这个对象会被移动到老生代中.在老生代中，使用的是标记清除和标记整理
  的方法，标记清除后会产生碎片内存，标记整理会在清除前进行整理，将存活的对象想一侧移动，随后清除另一侧的内存，这样空闲
  的内存是连续的。
内存溢出、内存泄露
  内存溢出就是程序在申请内存时，没有足够的空间供其使用。
  内存泄漏就是程序在申请内存后，无法释放已申请的内存空间，内存泄漏最终会导致内存溢出
ajax
  ajax是通过xmlHttpRequest来实现的，浏览器让xhr去获取数据，然后浏览器接着去干其他事，然后xhr返回数据后，浏览器接收
  返回的数据渲染页面
ts 泛型
  泛型可以用来创建可复用的数据类型，可以将函数、接口或类处理多种数据类型

react 性能优化
  useMemo和useCallback实现稳定的props
  useMemo只能缓存最近一次函数执行的结果，如果需要缓存多次函数执行的结果，可以使用memorizee
  列表项使用key属性
  使用发布订阅跳过中间组件的render： 
    react推荐将公共数据放在需要该状态的公共组件上，该状态放到公共组件上后就需要层层向下传递，直到目标组件为止，但是如果
    每次状态更新都会涉及中间组件的render，因此可以采用发布订阅的形式来解决这个问题，常用的有redux，React.createContext
 fetch和ajax
    fetch基于promise实现，逻辑更加清晰,采用了模块化设计
webpack
  loader和plugin
      loader可以看作具有文件转换功能的翻译器，告诉webpack在遇到哪些文件时使用哪些loader去加载和转换，使用loader的时候
      要注意执行顺序是从后到前的，如读取css文件时，先使用css-loader读取css文件，再由style-loader将css内容注入js中。常见loader：css-loader，style-loader。这个的原理大概是用js字符串将css内容存储起来，然后执行js操作dom向网页中动态
      加入html style标签
      plugin是用来扩展webpack功能的，通过在构建流程里注入钩子实现的，html-webpack-plugin(根据模版自动生成html代码，并自动引用css和js),clean-webpack-plugin 清除每次打包下没有使用的文件,commonChunkPlugin主要用于提取第三方库和
      公共模块，避免首屏加载的bundle文件体积过大，happypack开启多进程loader转换
  构建流程
    webpack在启动后会从entry里配置的module开始，递归解析entry依赖的所有module，每找一个module都会根据配置的loader去找对应的转换规则，对module进行转换后，再解析出当前module依赖的module，这些模块会以Entry为单位进行分组，一个Entry及其所有依赖的module被分到一个组也就是一个chunk，最后webpack会将chunk转换成文件输出(文件内其实是个自执行函数)，在这个流程中，webpack会在适当的时机执行plugin里定义的逻辑
  tree shaking
    tree-shaking本质是消除无用的代码，tree-shaking消除原理是依赖与es6模块特性，es6模块依赖关系是可以通过静态分析的，与
    运行时的状态无关。
    只处理函数和import/export变量，js动态语言特性使得分析比较困难
  webpack性能优化
    1.resolve字段告诉webpack怎么去搜索字段
    2.使用happypack(plugins)开启多线程loader转换，在整个构建流程中最耗时的就是loader对文件的转换了，通过happypack
      可以将任务分解给多个子进程，最后将结果发给主进程
    3.使用自动刷新，在webpack中加上--watch参数，在配置文件中对watchOptions进行配置。(通过向系统轮询文件变化来判断是否改变)
    4.开启热替换，开启后如果修改子模块就可以实现局部刷新，但如果修改js文件就会整页刷新
    5.压缩js、css，去掉无效代码、缩短变量名、去掉日志输出
    6.使用tree-shaking去除无效代码
    7.启用缓存来提升构建速度

126

git 148

151

152

159

161

http1.1 2.0 3.0区别
  http1的缺陷： 1. 连接无法复用，每次都需要经历三次握手 2. 队头阻塞 3. 消息首部体积大
  http2
    头部压缩:http2在客户端和服务端使用了首部表来跟踪和存储之前发送的首部信息，不需要每次都请求和响应都返回相同的字符串，
            使用索引代替了
  http1基于文本，所有数据都必须按顺序传输，不能并行传输，因为接收端并不知道这些字符的顺序。
  http2在客户端和服务端建立连接后，会在双方建立一个双向流通道，基于二进制数据帧和流的概念，其中帧对数据进行顺序标识，这样浏览器收到之后就可以按照序列对数据进行合并，而不会出现合并之后数据错乱对情况。因为有了序列，服务器就可以并行的传输数据。从而
  实现了一个tcp连接就可以并发执行多个请求。
  http2对同一域名下的所有请求都是基于流，也就是同一域名下不管访问多少文件都只建立一路连接
  http2服务器推送，就是服务器不再是完全被动地响应请求，也可以新建流主动向客户端发送消息。就比如说客户端只请求了html，
  服务端连同css、html、js一起返回了，这样通过一轮http通信就得到了全部资源，提高了性能，这个需要服务端写代码去实现
移动端适配1px解决方案
  设备像素比 = 物理像素 / CSS像素
    目前主流的屏幕的设备像素比是2，所以想实现1的物理像素就应该设置0.5px的css像素，这个在安卓系统是不支持的，ios上
    才能支持。
    方案1: 使用边框图片，border，border-image，缺点：当border颜色变了需要重新制作图片
    方案2: 使用伪元素，然后用scale进行缩放  缺点：占据了伪元素，容易引起冲突

  阿里一面 40min
    公司项目经历
    跨端如何支持小程序
    react开发相比于原生开发好处
    重绘回流
    浏览器计算dom节点位置耗时原因
    类和hooks区别
    hooks实现生命周期
    路由实现(hash,history)
    如何原生监听路由
    react状态管理
    react fiber
    输入url按下回车会发生啥
    dns域名解析
    https和http
    http1.1 2.0 3.0区别
    服务器如何接收http请求，如何定位相应服务器程序，服务器如何处理请求
    xss
    token生成

  字节一面 41min
    公司项目经历
    hooks和class的区别
    说输出
    alert(a);
    a();
    a = 3;
    function a (){
      alert(10)
    }
    alert(a);
    a = 6;
    a()
    如何学习
    同时获取2个api的结果
    手写promise.all
    进程线程
    浏览器存储机制
    cookie与localstorage的区别
    单点登录
    tcp如何保证数据传输
    项目难点
    判断是否回文数字

  字节二面 60min
    如何学习前端，看过哪些书
    进程如何通信
    计算机win64
    进程和线程
    线程之间通信方式
    实现点击table里单元格拿到里面的内容
    实现发布订阅，on，emit，off，清除其中一个方法
    class 的protect pravila public
    跨域
    cors原理
    正向代理和反向代理
    登录流程，状态持久化
    token如何使用
    判断object和array的方法
    算法
    无重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合，字符串每个字符均不相同。
    示例:

    输入：S = "qwe"

     输出：["qwe", "qew", "wqe", "weq", "ewq", "eqw"]
    时间复杂度

  字节三面 35min
    react、vue设计思想
    常见状态码
    协商缓存
    发布订阅和观察者模式区别
    webpack设计理念
    webpack的plugin和loader区别
    原型链
    项目难点
    事件循环机制
    实现deepClone


  美团一面 60min
    自我介绍
    flex，主轴侧轴,flex-grow
    css选择器权重
    移动端适配
    rem、em
    js数据类型
    typeof Object
    说输出，函数提升变量提升相关
    说输出，原型链相关
    说输出，闭包相关
    call、bind区别
    浏览器渲染过程
    http状态码
    协商缓存
    tpc/ip四层结构
    http，tcp，ip各属于哪层
    tcp,udp区别
    三次握手四次挥手
    长连接和短连接
    判断链表是否有环
    vue的data是什么类型，为什么
    v-modal，如何实现
    v-for的key，可以使用index
    $nextTick
    事件循环机制
    二叉树遍历方法
    在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）

美团二面
    如何实现跨端
    公司项目
    C语言编码过程
    线程和进程
    渲染进程有什么线程
    线程通信方式
    TCP如何保证可靠性
    阻塞控制用了什么算法
    UDP协议
    http2和http1的区别
    头部压缩中的动态表用来存储啥，静态表用来存储啥
    协商缓存
    last-modify缺点
    js如何处理异步任务
    浏览器有什么进程
    new worker
    项目难点
    vue和react区别
    vue响应式原理
    判断一个字符串中的括号是否合法(优化)
    m*n棋盘，一颗棋子从左上角移动到右下角总共多少条路径(只能向下或者向右移动)
    给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小(优化)


 虾皮一面
    手写bind
    this的指向
    一个二叉树每个节点的左右两个子树的高度差绝对值不超过一
    闭包和作用域
    进程和线程
    xss和csrf